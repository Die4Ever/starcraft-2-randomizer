include "TriggerLibs/NativeLib"

// https://mapster.talv.space/galaxy/reference#catalog
// https://sc2mapster.fandom.com/wiki/Tutorials

//string number_types;
fixed min_percent;
fixed max_percent;
int seed;
int changes_per_race;
int changes_per_unit;

struct Change {
    string entry;
    string field;
    fixed oldval;
    fixed newval;
};

struct RaceChanges {
    string name;
    Change[64] changes;
    int len;
};
const int no_race=0;
const int terran=1;
const int protoss=2;
const int zerg=3;
RaceChanges[4] race_changes;

struct RandomizedField {
    int cat;
    int type;
    string name;
};
RandomizedField[100] randomized_fields;
const int type_fixed = 0;
const int type_int = 1;

void AddRandomizedField(int cat, int type, string name)
{
    int i;
    for( i=0; i<100; i+=1 ) {
        if( randomized_fields[i].name == "" ) {
            randomized_fields[i].cat = cat;
            randomized_fields[i].type = type;
            randomized_fields[i].name = name;
            return;
        }
    }
}

int GetRandomField(int cat)
{
    int num;
    int i;

    num = 0;
    for( i=0; i<100; i+=1 ) {
        if( randomized_fields[i].cat == cat && randomized_fields[i].name != "" ) {
            num+=1;
        }
    }

    num = RandomInt(0, num-1);
    for( i=0; i<100; i+=1 ) {
        if( randomized_fields[i].cat == cat && randomized_fields[i].name != "" ) {
            if( num == 0 ) {
                return i;
            }
            num-=1;
        }
    }

    return -1;
}

string[100] notes;
void note_add(string val)
{
    int i;
    for( i=0; i<100; i+=1 ) {
        if( notes[i] == val ) {
            return;
        }
        if( notes[i] == "" ) {
            notes[i] = val;
            return;
        }
    }
}

void notes_log()
{
    int i;
    for( i=0; i<100; i+=1 ) {
        if( notes[i] == "" ) {
            continue;
        }
        TriggerDebugOutput(1, StringToText(notes[i]), false );
    }
}

void debug(string message)
{
    TriggerDebugOutput(1, StringToText(message), false );
}

void info(string message)
{
    TriggerDebugOutput(1, StringToText(message), false );
}

void warning(string message)
{
    TriggerDebugOutput(1, StringToText(message), false );
}

void error(string message)
{
    TriggerDebugOutput(1, StringToText(message), false );
}

void fatal(string message)
{
    TriggerDebugOutput(1, StringToText(message), false );
}

bool add_change(int self, string entry, string field, fixed oldval, fixed newval)
{
    int len;

    len = race_changes[self].len;
    if( len >= 64 ) {
        error("add_change failed with "+entry+" "+field+" changing from "+FixedToString(oldval,5)+" to "+FixedToString(newval,5));
        return false;
    }
    race_changes[self].changes[len].entry = entry;
    race_changes[self].changes[len].field = field;
    race_changes[self].changes[len].oldval = oldval;
    race_changes[self].changes[len].newval = newval;
    race_changes[self].len += 1;

    //message = "add_change with "+entry+" "+field+" changing from "+FixedToString(oldval,5)+" to "+FixedToString(newval,5);
    //TriggerDebugOutput(1, StringToText(message), false );

    return true;
}

void log_changes(int self)
{
    int i;
    string message;

    message = race_changes[self].name + " Changes: ";

    for( i=0; i < race_changes[self].len; i+=1 ) {
        if( i > 0 ) {
            message += ", ";
        }
        message +=
            race_changes[self].changes[i].entry+" "+race_changes[self].changes[i].field
            + " changed from "
            + FixedToString(race_changes[self].changes[i].oldval,5)
            + " to "+FixedToString(race_changes[self].changes[i].newval,5);
    }

    debug(message );

    //UIDisplayMessage( PlayerGroupAll(), c_messageAreaChat, StringToText(message) );
    //UIShowTextCrawl( PlayerGroupAll(), StringToText(race_changes[self].name + " Changes: "), StringToText(message), 6, SoundLink("Silent", -1), SoundLink("Silent", -1));
    // https://mapster.talv.space/galaxy/reference/dialog-create
    // https://mapster.talv.space/galaxy/reference#dialog-dialog-items
}

fixed rng(fixed min, fixed max) {
    return RandomFixed(min, max);
}

fixed randomize(fixed val) {
    // probably should make all changes far away from 100%, since there will be few things changed
    return val * rng(min_percent, max_percent) / 100.0;
}


bool set_field_string(int cat, string entry, string field, string value)
{
    playergroup allplayers;
    int player;
    int num_players;
    int i;

    allplayers = PlayerGroupAll();
    num_players = PlayerGroupCount(allplayers);
    for( i=1; i<=num_players; i+=1 ) {
        player = PlayerGroupPlayer( allplayers, i );
        if( ! CatalogFieldValueSet(cat, entry, field, player, value) ) {
            return false;
        }
    }
    return true;
}


bool set_field_fixed(int cat, string entry, string field, fixed value)
{
    playergroup allplayers;
    int player;
    int num_players;
    int i;
    allplayers = PlayerGroupAll();
    num_players = PlayerGroupCount(allplayers);
    for( i=1; i<=num_players; i+=1 ) {
        player = PlayerGroupPlayer( allplayers, i );
        if( ! libNtve_gf_CatalogFieldValueSetAsReal(cat, entry, field, player, value) ) {
            return false;
        }
    }
    return true;
}


bool rando_field_fixed(int cat, string entry, string field, int changes_id)
{
    fixed getval;
    fixed setval;
    fixed value;

    getval = libNtve_gf_CatalogFieldValueGetAsReal(cat, entry, field, 1);
    if( getval == 0 ) {
        error(entry+" "+field+" failed to read");
        return false;
    }
    value = randomize(getval);
    if( value == getval ) {
        return false;
    }
    if( ! set_field_fixed(cat, entry, field, value ) ) {
        error(entry+" "+field+" was "+FixedToString(getval,5)+", failed to change to "+FixedToString(value,5));
        return false;
    }
    setval = libNtve_gf_CatalogFieldValueGetAsReal(cat, entry, field, 1);
    if( getval == setval ) { return false; }

    add_change(changes_id, entry, field, getval, setval);

    if( field == "LifeMax" ) {
        if( ! set_field_fixed(cat, entry, "LifeStart", value) ) {
            error(entry+" LifeStart failed to set to "+FixedToString(value,5));
            return false;
        }
    }
    if( field == "ShieldsMax" ) {
        if( ! set_field_fixed(cat, entry, "ShieldsStart", value) ) {
            error(entry+" ShieldsStart failed to set to "+FixedToString(value,5));
            return false;
        }
    }
    return true;
}


bool rando_field_int(int cat, string entry, string field, int changes_id)
{
    int getval;
    int setval;
    int value;

    getval = CatalogFieldValueGetAsInt(cat, entry, field, 1);
    if( getval == 0 ) {
        error(entry+" "+field+" failed to read");
        return false;
    }
    value = FixedToInt( randomize(getval) );
    if( value == getval ) {
        return false;
    }
    if( ! set_field_string(cat, entry, field, IntToString(value) ) ) {
        error(entry+" "+field+" was "+IntToString(getval)+", failed to change to "+IntToString(value));
        return false;
    }
    setval = CatalogFieldValueGetAsInt(cat, entry, field, 1);
    if( getval == setval ) { return false; }

    add_change(changes_id, entry, field, getval, setval);

    if( field == "LifeMax" ) {
        if( ! set_field_fixed(cat, entry, "LifeStart", value) ) {
            error(entry+" LifeStart failed to set to "+FixedToString(value,5));
            return false;
        }
    }
    if( field == "ShieldsMax" ) {
        if( ! set_field_fixed(cat, entry, "ShieldsStart", value) ) {
            error(entry+" ShieldsStart failed to set to "+FixedToString(value,5));
            return false;
        }
    }
    return true;
}


int get_race_id(int cat, string scope, string entry) {
    string EditorCategories;
    string race;

    if( CatalogFieldExists(scope, "EditorCategories") ) {
        EditorCategories = CatalogFieldValueGet(cat, entry, "EditorCategories", 1);
        if( ! StringContains(EditorCategories, "ObjectFamily:Melee", c_stringAnywhere, c_stringCase) ) {
            return no_race;
        }
    } else {
        EditorCategories = "";
    }

    if( CatalogFieldExists(scope, "Race") ) {
        race = "Race:" + CatalogFieldValueGet(cat, entry, "Race", 1);
    }
    else {
        race = EditorCategories;
    }

    if( StringContains(race, "Race:Terr", c_stringAnywhere, c_stringCase) ) {
        return terran;
    }
    else if( StringContains(race, "Race:Prot", c_stringAnywhere, c_stringCase) ) {
        return protoss;
    }
    else if( StringContains(race, "Race:Zerg", c_stringAnywhere, c_stringCase) ) {
        return zerg;
    }
    
    return no_race;
}


void randomize_start() {
    // starting workers, mineral patches, geysers...
}


void randomize_workers() {
}


int randomize_fields(int cat, string entry, int race_id, int num_fields) {
    int i;
    int slot;
    int num;
    bool[100] mask;

    num = 0;
    for( i=0; num<num_fields && i<32; i+=1 ) {
        slot = GetRandomField(cat);
        if( slot == -1 ) {
            return num;
        }
        if( mask[slot] ) { continue; }
        mask[slot] = true;

        if( randomized_fields[slot].type == type_fixed ) {
            if( rando_field_fixed(cat, entry, randomized_fields[slot].name, race_id) ) {
                num+=1;
            }
        }
        else if( randomized_fields[slot].type == type_int ) {
            if( rando_field_int(cat, entry, randomized_fields[slot].name, race_id) ) {
                num+=1;
            }
        }
    }

    return num;
}


void randomize_effect(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogEffect;
    if( entry == "" ) {
        return;
    }

    randomize_fields(cat, entry, race_id, num_fields);

    note_add(CatalogEntryScope(cat, entry));
}


void randomize_weapon(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogWeapon;

    if( entry == "" ) {
        return;
    }

    randomize_fields(cat, entry, race_id, num_fields);

    // CWeapon_DisplayEffect is where the damage is defined?

    // scopes
    // CWeaponLegacy
    // CWeaponStrafe

    //set_add(CatalogEntryScope(cat, entry));
}


void randomize_upgrade(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogUpgrade;

    if( entry == "" ) {
        return;
    }

    // CUpgrade BattlecruiserBehemothReactor has <EffectArray Reference="Unit,Battlecruiser,EnergyStart" Value="25"/>
    // maybe if EffectArray[i].Operation is anything except Set, then it can be randomized
    randomize_fields(cat, entry, race_id, num_fields);
}


void randomize_ability(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogAbil;
    string scope;
    string type;
    int len;
    int i;
    string val;

    if( entry == "" ) {
        return;
    }

    randomize_fields(cat, entry, race_id, num_fields);

    // scopes
    // CAbilBuild
    // CAbilMorphPlacement
    // CAbilMove
    // CAbilStop
    // CAbilBuildable
    // CAbilQueue
    // CAbilArmMagazine
    // CAbilResearch
    // CAbilMorph
    // CAbilAttack
    // CAbilWarpable
    // CAbilEffectTarget
    // CAbilTrain
    // CAbilRally
    // CAbilEffectInstant
    // CAbilAugment
    // CAbilMerge
    // CAbilTransport
    // CAbilMergeable
    // CAbilBehavior
    // CAbilRedirectInstant
    // CAbilRedirectTarget

    // InfoArray types
    // SAbilBuildInfo has [i].Unit for unit name and [i].Time for build time
    // SAbilMorphInfo
    // SAbilArmMagazineInfo
    // SAbilResearchInfo
    // SAbilTrainInfo
    // SAbilRallyInfo

    // "EngineeringBayResearch" is a CAbilResearch with InfoArray[3].Upgrade == TerranInfantryWeaponsLevel1, .Time=160, .Resource[Minerals/Vespene]
    scope = CatalogEntryScope(cat, entry);
    //set_add(scope);
    //len = CatalogFieldValueCount(cat, entry, "InfoArray", 1);
    //TriggerDebugOutput(1, StringToText(entry+" has InfoArray "+IntToString(len)), false );
    //TriggerDebugOutput(1, StringToText(entry+" has scope: "+scope), false );
}


void randomize_unit(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogUnit;
    string scope = "CUnit";
    int i;
    int len;
    int slot;
    string val;

    randomize_fields(cat, entry, race_id, num_fields);

    // check abilities, weapons, and upgrades
    len = CatalogFieldValueCount(cat, entry, "AbilArray", 1);
    for( i=0; i<len; i+=1 ) {
        val = CatalogFieldValueGet(cat, entry, "AbilArray["+IntToString(i)+"].Link", 1);
        randomize_ability(val, race_id, num_fields);
    }

    len = CatalogFieldValueCount(cat, entry, "WeaponArray", 1);
    for( i=0; i<len; i+=1 ) {
        val = CatalogFieldValueGet(cat, entry, "WeaponArray["+IntToString(i)+"].Link", 1);
        randomize_weapon(val, race_id, num_fields);
    }
}


void randomize_units(int changes_per_race) {
    int cat = c_gameCatalogUnit;
    string scope = "CUnit";
    string entry;
    string cost_category;
    int num_data;
    int race_id;
    int i;
    int slot;

    num_data = CatalogEntryCount(cat);

    for( i=1; i<=num_data; i+=1 ) {

        if( race_changes[terran].len >= changes_per_race
            && race_changes[protoss].len >= changes_per_race
            && race_changes[zerg].len >= changes_per_race
        ) {
            break;
        }
        GameSetSeed( 5 + seed + i);
        slot = RandomInt(1, num_data);

        entry = CatalogEntryGet(cat, slot);
        race_id = get_race_id(cat, scope, entry);
        if( race_id == no_race ) {
            continue;
        }
        if( race_changes[race_id].len >= changes_per_race ) {
            continue;
        }

        cost_category = CatalogFieldValueGet(cat, entry, "CostCategory", 1);
        if( cost_category != "Army" && cost_category != "Technology" ) {
            continue;
        }

        GameSetSeed( 5 + seed + slot);
        randomize_unit(entry, race_id, changes_per_unit);
    }

    GameSetSeed(seed);
}


void main () {
    bool seed_was_locked;
    int oldseed;
    //int changes_per_category;
    int i;

    seed=13371;
    min_percent = 50;
    max_percent = 150;
    changes_per_race = 50;
    changes_per_unit = 3;
    
    AddRandomizedField(c_gameCatalogUnit, type_int, "CostResource[Minerals]");
    AddRandomizedField(c_gameCatalogUnit, type_int, "CostResource[Vespene]");
    AddRandomizedField(c_gameCatalogUnit, type_int, "Food");
    AddRandomizedField(c_gameCatalogUnit, type_int, "LifeMax");
    AddRandomizedField(c_gameCatalogUnit, type_int, "ShieldsMax");
    AddRandomizedField(c_gameCatalogUnit, type_int, "EnergyMax");
    AddRandomizedField(c_gameCatalogUnit, type_fixed, "Acceleration");
    AddRandomizedField(c_gameCatalogUnit, type_fixed, "Speed");

    AddRandomizedField(c_gameCatalogWeapon, type_fixed, "Range");

    AddRandomizedField(c_gameCatalogEffect, type_int, "Amount");

    seed_was_locked = GameIsSeedLocked();
    GameSetSeed(seed);

    //number_types = " CFixed CGameTime CGameAcceleration CGameSpeed CGameRate SAccumulatedFixed int32 ";

    randomize_workers();
    randomize_start();
    randomize_units(changes_per_race);

    race_changes[no_race].name = "General";
    race_changes[terran].name = "Terran";
    race_changes[protoss].name = "Protoss";
    race_changes[zerg].name = "Zerg";
    for(i=0; i<4 ; i+=1 ) {
        log_changes(i);
    }

    notes_log();
    GameSetSeedLocked(seed_was_locked);
}
