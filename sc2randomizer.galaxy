include "TriggerLibs/NativeLib"
//include "TriggerLibs/MeleeAI"

// https://mapster.talv.space/galaxy/reference#catalog
// https://sc2mapster.fandom.com/wiki/Tutorials

//string number_types;
fixed min_percent;
fixed max_percent;
int seed;
const int max_factions = 8;
int num_factions;
int num_bans;
int changes_per_faction;
int changes_per_unit;

bool[max_factions * 4 * 16] players_bans;
int[16] players_picks;
bool[16] players_waiting;

const string dialog_title = "StarCraft 2 Randomizer Alpha";
const int default_player = 1;
int dialog_start;
int seed_editbox;
int num_factions_editbox;
int num_bans_editbox;
int changes_per_faction_editbox;
int changes_per_unit_editbox;
int min_percent_editbox;
int max_percent_editbox;
int dialog_bans;
int changes_list;
int dialog_wait;
int dialog_pick_faction;
int ban_button;
int pick_button;
int factions_dropdown;
trigger dialog_timeout;

struct Change {
    int cat;
    string entry;
    string field;
    string friendly_name;
    fixed oldval;
    fixed newval;
};

struct RaceChanges {
    string name;
    Change[128] changes;
    int len;
};
const int no_race=0;
const int terran=1;
const int protoss=2;
const int zerg=3;
RaceChanges[max_factions *4] race_changes;

struct RandomizedField {
    //int cat;
    int type;
    string scope;
    string name;
    string friendly_name;
    bool is_array;
};
RandomizedField[256] randomized_fields;
const int type_unknown = 0;
const int type_fixed = 1;
const int type_int = 2;
// scopes
const int type_unit = 3;
const int type_ability = 4;
const int type_effect = 5;
const int type_weapon = 6;
const int type_upgrade = 7;
const int type_behavior = 8;

const int type_struct = 100;

void debug(string message)
{
    //text t;
    //t = StringToText(message);
    //TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    //t = StringToText("debug: ") + t;
    //UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}

void info(string message)
{
    text t;
    t = StringToText(message);
    TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    //t = StringToText("info: ") + t;
    //UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}

void notice(string message)
{
    text t;
    t = StringToText(message);
    TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}

void warning(string message)
{
    text t;
    t = StringToText(message);
    TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    t = StringToText("warning: ") + t;
    UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}

void err(string message)
{
    text t;
    t = StringToText(message);
    TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    t = StringToText("error: ") + t;
    UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}

void fatal(string message)
{
    text t;
    t = StringToText(message);
    TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    t = StringToText("fatal error: ") + t;
    UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}


playergroup GetPlayersOfType(int type)
{
    playergroup players;
    int len;
    int i;
    players = PlayerGroupCopy(PlayerGroupActive());
    len = PlayerGroupCount(players);
    for( i=1; i<=len; i+=1 ) {
        if( PlayerType( PlayerGroupPlayer(players, i) ) != type ) {
            PlayerGroupRemove(players, PlayerGroupPlayer(players, i) );
        }
    }

    return players;
}


void AddRandomizedField(string scope, int type, string name)
{
    int i;
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].name == "" ) {
            randomized_fields[i].scope = scope;
            randomized_fields[i].type = type;
            randomized_fields[i].name = name;
            randomized_fields[i].is_array = false;
            return;
        }
    }
    err("AddRandomizedField full");
}

void AddRandomizedFieldFriendlyName(string scope, int type, string name, string friendly_name)
{
    int i;
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].name == "" ) {
            randomized_fields[i].scope = scope;
            randomized_fields[i].type = type;
            randomized_fields[i].name = name;
            randomized_fields[i].friendly_name = friendly_name;
            randomized_fields[i].is_array = false;
            return;
        }
    }
    err("AddRandomizedFieldFriendlyName full");
}

void AddRandomizedFieldArray(string scope, int type, string name)
{
    int i;
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].name == "" ) {
            randomized_fields[i].scope = scope;
            randomized_fields[i].type = type;
            randomized_fields[i].name = name;
            randomized_fields[i].is_array = true;
            return;
        }
    }
    err("AddRandomizedFieldArray full");
}

void CopyRandomizedFields(string from, string scope, string friendly_name)
{
    int i;
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].scope == from ) {
            if( randomized_fields[i].is_array ) {
                AddRandomizedFieldArray(scope, randomized_fields[i].type, randomized_fields[i].name);
            }
            else {
                AddRandomizedFieldFriendlyName(scope, randomized_fields[i].type, randomized_fields[i].name, friendly_name);
            }
        }
    }
}

int GetRandomField(string scope)
{
    int num;
    int i;

    num = 0;
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].scope == scope && randomized_fields[i].name != "" ) {
            num+=1;
        }
    }

    if( num == 0 ) {
        return -1;
    }

    num = RandomInt(0, num-1);
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].scope == scope && randomized_fields[i].name != "" ) {
            if( num == 0 ) {
                return i;
            }
            num-=1;
        }
    }

    return -1;
}

string[100] notes;
bool note_add(string val)
{
    int i;
    for( i=0; i<100; i+=1 ) {
        if( notes[i] == val ) {
            return false;
        }
        if( notes[i] == "" ) {
            info("note_add "+val);
            notes[i] = val;
            return true;
        }
    }
    return false;
}

void notes_log()
{
    int i;
    for( i=0; i<100; i+=1 ) {
        if( notes[i] == "" ) {
            continue;
        }
        TriggerDebugOutput(1, StringToText(notes[i]), false );
    }
}


int find_change(int self, string entry, string field)
{
    int i;
    for( i=0; i < race_changes[self].len; i+=1 ) {
        if( race_changes[self].changes[i].entry == entry && race_changes[self].changes[i].field == field ) {
            return i;
        }
    }
    return -1;
}

bool add_change(int self, int cat, string entry, string field, string friendly_name, fixed oldval, fixed newval)
{
    int len;

    len = race_changes[self].len;
    if( len >= 256 ) {
        err("add_change failed with "+entry+" "+field+" changing from "+FixedToString(oldval,5)+" to "+FixedToString(newval,5));
        return false;
    }
    race_changes[self].changes[len].cat = cat;
    race_changes[self].changes[len].entry = entry;
    race_changes[self].changes[len].field = field;
    race_changes[self].changes[len].friendly_name = friendly_name;
    race_changes[self].changes[len].oldval = oldval;
    race_changes[self].changes[len].newval = newval;
    race_changes[self].len += 1;

    debug("add_change with "+entry+" "+field+" "+friendly_name+" changing from "+FixedToString(oldval,5)+" to "+FixedToString(newval,5));

    return true;
}


fixed rng(fixed min, fixed max) {
    return RandomFixed(min, max);
}

fixed randomize(fixed val) {
    fixed percent;
    // probably should make all changes far away from 100%, since there will be few things changed
    percent = rng(min_percent, max_percent);
    if( (percent - min_percent) < (max_percent - percent) ) {
        percent = (percent+min_percent) / 2.0;
    } else {
        percent = (percent+max_percent) / 2.0;
    }
    return val * percent / 100.0;
}


bool set_field_string(int cat, string entry, string field, string value)
{
    if( ! CatalogFieldValueSet(cat, entry, field, default_player, value) ) {
        return false;
    }
    return true;
}

bool set_field_string_player(int player, int cat, string entry, string field, string value)
{
    if( ! CatalogFieldValueSet(cat, entry, field, player, value) ) {
        return false;
    }
    return true;
}

bool set_field_string_all(int cat, string entry, string field, string value)
{
    playergroup allplayers;
    int player;
    int num_players;
    int i;

    allplayers = PlayerGroupAll();
    num_players = PlayerGroupCount(allplayers);
    for( i=1; i<=num_players; i+=1 ) {
        player = PlayerGroupPlayer( allplayers, i );
        if( ! CatalogFieldValueSet(cat, entry, field, player, value) ) {
            return false;
        }
    }
    return true;
}


bool set_field_fixed(int cat, string entry, string field, fixed value)
{
    if( ! libNtve_gf_CatalogFieldValueSetAsReal(cat, entry, field, default_player, value) ) {
        return false;
    }
    return true;
}

bool set_field_fixed_all(int cat, string entry, string field, fixed value)
{
    playergroup allplayers;
    int player;
    int num_players;
    int i;
    allplayers = PlayerGroupAll();
    num_players = PlayerGroupCount(allplayers);
    for( i=1; i<=num_players; i+=1 ) {
        player = PlayerGroupPlayer( allplayers, i );
        if( ! libNtve_gf_CatalogFieldValueSetAsReal(cat, entry, field, player, value) ) {
            return false;
        }
    }
    return true;
}


void apply_changes(int r, int player)
{
    int i;
    int cat;
    string entry;
    string field;
    fixed f;
    fixed oldf;
    string val;
    string oldval;
    string message;

    message = race_changes[r].name + " ("+IntToString(r)+") " + IntToString(race_changes[r].len) + " Changes for Player "+IntToString(player) + ":";
    info(message);
    message = "--- ";

    for( i=0; i < race_changes[r].len; i+=1 ) {
        if( StringLength(message) > 0 ) {
            message += ", ";
        }

        cat = race_changes[r].changes[i].cat;
        entry = race_changes[r].changes[i].entry;
        field = race_changes[r].changes[i].field;
        f = race_changes[r].changes[i].newval;
        oldf = race_changes[r].changes[i].oldval;

        if( IntToFixed(FixedToInt(f)) == f ) {
            val = IntToString(FixedToInt(f));
            oldval = IntToString(FixedToInt(oldf));
        }
        else {
            val = FixedToString(f,5);
            oldval = FixedToString(oldf, 5);
        }
        set_field_string_player(player, cat, entry, field, val );

        message += entry+" "+field+" changed from "+oldval+" to "+val;

        if( field == "LifeMax" ) {// TODO: maybe need a list of linked values to keep proportional instead of hardcoded
            if( ! set_field_string_player(player, cat, entry, "LifeStart", val ) ) {
                err(entry+" LifeStart failed to set to "+val);
            }
        }
        if( field == "ShieldsMax" ) {
            if( ! set_field_string_player(player, cat, entry, "ShieldsStart", val ) ) {
                err(entry+" ShieldsStart failed to set to "+val);
            }
        }

        if( StringLength(message) > 200 ) {
            info( message );
            message = "--- ";
        }
    }

    if( StringLength(message) > 0 ) {
        info(message);
    }
    info(" ");
}


bool rando_field_fixed(int cat, string entry, string field, string friendly_name, int changes_id)
{
    fixed getval;
    fixed setval;
    fixed value;

    if( find_change(changes_id, entry, field) != -1 ) {
        return false;
    }

    getval = libNtve_gf_CatalogFieldValueGetAsReal(cat, entry, field, default_player);
    if( getval == 0 ) {
        debug(entry+" "+field+" failed to read");
        return false;
    }
    value = randomize(getval);
    if( value == getval ) {
        return false;
    }
    if( ! set_field_fixed(cat, entry, field, value ) ) {
        err(entry+" "+field+" was "+FixedToString(getval,5)+", failed to change to "+FixedToString(value,5));
        return false;
    }
    setval = libNtve_gf_CatalogFieldValueGetAsReal(cat, entry, field, default_player);
    // TODO: determine if the re-read is needed
    if( getval == setval ) { return false; }

    if( ! set_field_fixed(cat, entry, field, getval ) ) {
        err(entry+" "+field+" was "+FixedToString(value,5)+", failed to change back to "+FixedToString(getval,5));
        return false;
    }

    add_change(changes_id, cat, entry, field, friendly_name, getval, setval);// TODO: maybe need to save the type or precision
    set_field_fixed(cat, entry, field, getval );

    return true;
}


bool rando_field_int(int cat, string entry, string field, string friendly_name, int changes_id)
{
    int getval;
    int setval;
    int value;

    if( find_change(changes_id, entry, field) != -1 ) {
        return false;
    }

    getval = CatalogFieldValueGetAsInt(cat, entry, field, default_player);
    if( getval == 0 ) {
        debug(entry+" "+field+" failed to read");
        return false;
    }
    value = FixedToInt( randomize(getval) );
    if( value == getval ) {
        return false;
    }
    if( ! set_field_string(cat, entry, field, IntToString(value) ) ) {
        err(entry+" "+field+" was "+IntToString(getval)+", failed to change to "+IntToString(value));
        return false;
    }
    setval = CatalogFieldValueGetAsInt(cat, entry, field, default_player);
    // TODO: determine if the re-read is needed
    if( getval == setval ) { return false; }

    if( ! set_field_string(cat, entry, field, IntToString(getval) ) ) {
        err(entry+" "+field+" was "+IntToString(value)+", failed to change back to "+IntToString(getval));
        return false;
    }

    add_change(changes_id, cat, entry, field, friendly_name, getval, setval);
    set_field_string(cat, entry, field, IntToString(getval) );

    return true;
}


int get_race_id(int cat, string scope, string entry) {
    string EditorCategories;
    string race;

    if( CatalogFieldExists(scope, "EditorCategories") ) {
        EditorCategories = CatalogFieldValueGet(cat, entry, "EditorCategories", default_player);
        if( ! StringContains(EditorCategories, "ObjectFamily:Melee", c_stringAnywhere, c_stringCase) ) {
            return no_race;
        }
    } else {
        EditorCategories = "";
    }

    if( CatalogFieldExists(scope, "Race") ) {
        race = "Race:" + CatalogFieldValueGet(cat, entry, "Race", default_player);
    }
    else {
        race = EditorCategories;
    }

    if( StringContains(race, "Race:Terr", c_stringAnywhere, c_stringCase) ) {
        return terran;
    }
    else if( StringContains(race, "Race:Prot", c_stringAnywhere, c_stringCase) ) {
        return protoss;
    }
    else if( StringContains(race, "Race:Zerg", c_stringAnywhere, c_stringCase) ) {
        return zerg;
    }
    
    return no_race;
}


void modify_resources(string name, fixed percent) {
    int i;
    int num;
    int val;
    unitgroup units;
    unit u;

    units = UnitGroup(name, 0, RegionEntireMap(), UnitFilter(0,0,0,0), 99999 );
    num = UnitGroupCount(units, c_unitCountAll);
    debug("found "+IntToString(num)+" of "+name);
    for( i=0; i<num; i+=1 ) {
        u = UnitGroupUnit(units, i);
        val = UnitGetPropertyInt(u, c_unitPropResources, true);
        val = FixedToInt(IntToFixed(val) * percent / 100.0);
        UnitSetPropertyInt(u, c_unitPropResources, val);
    }
}


void modify_behavior_resource(string name, fixed amount_percent, fixed amount, fixed time) {
    fixed val;

    // TODO:
    // Catalog field 'HarvestAmount' could not be written (Core: access denied to required object or service)
    // Catalog field 'HarvestTime' could not be written (Core: access denied to required object or service)
    // Catalog field 'Capacity' could not be written (Core: access denied to required object or service)
    // Catalog field 'Contents' could not be written (Core: access denied to required object or service)

    //val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "HarvestAmount", default_player);
    //val = val * amount / 100.0;
    //set_field_fixed(c_gameCatalogBehavior, name, "HarvestAmount", val );

    //val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "HarvestTime", default_player);
    //val = val * time / 100.0;
    //set_field_fixed(c_gameCatalogBehavior, name, "HarvestTime", val );

    //val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "Capacity", default_player);
    //val = val * amount_percent / 100.0;
    //set_field_string(c_gameCatalogBehavior, name, "Capacity", FixedToString(val,0) );

    //val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "Contents", default_player);
    //val = val * amount_percent / 100.0;
    //set_field_string(c_gameCatalogBehavior, name, "Contents", FixedToString(val,0) );
}


void randomize_economy() {
    fixed amount_percent;
    fixed harvestamount_percent;
    fixed harvesttime_percent;

    GameSetSeed( 0451 + seed );

    // CBehaviorResource minerals
    amount_percent = randomize(100);
    harvestamount_percent = randomize(100);
    harvesttime_percent = randomize(100);
    modify_behavior_resource("HighYieldMineralFieldMinerals", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HighYieldMineralFieldMinerals750", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMinerals", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMinerals450", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMinerals750", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMineralsNoRemove", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMineralsOpaque", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMineralsOpaque900", amount_percent, harvestamount_percent, harvesttime_percent);
    // TODO: fix these
    //add_change(no_race, 0, "Minerals Harvest", "Amount", "", 5, 5.0*harvestamount_percent/100);
    //add_change(no_race, 0, "Minerals Harvest", "Time", "", 2.786, 2.786*harvesttime_percent/100);

    // minerals
    modify_resources("MineralField", amount_percent);
    modify_resources("MineralField450", amount_percent);
    modify_resources("MineralField750", amount_percent);
    modify_resources("LabMineralField", amount_percent);
    modify_resources("LabMineralField750", amount_percent);
    modify_resources("BattleStationMineralField", amount_percent);
    modify_resources("BattleStationMineralField750", amount_percent);
    modify_resources("MineralFieldDefault", amount_percent);
    modify_resources("MineralFieldOpaque", amount_percent);
    modify_resources("MineralFieldOpaque900", amount_percent);
    modify_resources("PurifierMineralField", amount_percent);
    modify_resources("PurifierMineralField750", amount_percent);
    modify_resources("PurifierRichMineralField", amount_percent);
    modify_resources("PurifierRichMineralField750", amount_percent);
    modify_resources("RichMineralField", amount_percent);
    modify_resources("RichMineralField750", amount_percent);
    modify_resources("RichMineralFieldDefault", amount_percent);
    add_change(no_race, 0, "Minerals", "%", "", 100, amount_percent);

    // CBehaviorResource gas
    amount_percent = randomize(100);
    harvestamount_percent = randomize(100);
    harvesttime_percent = randomize(100);
    modify_behavior_resource("HarvestableRichVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableRichVespeneGeyserGasProtoss", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableRichVespeneGeyserGasZerg", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableTerrazineGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableTerrazineGeyserGasProtoss", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableTerrazineGeyserGasZerg", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableVespeneGeyserGasProtoss", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableVespeneGeyserGasZerg", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("RawRichVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("RawTerrazineGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("RawVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    // TODO: fix these
    //add_change(no_race, 0, "Gas Harvest", "Amount", "", 4, 4.0*harvestamount_percent/100);
    //add_change(no_race, 0, "Gas Harvest", "Time", "", 1.981, 1.981*harvesttime_percent/100);

    // gasses
    modify_resources("ProtossVespeneGeyser", amount_percent);
    modify_resources("PurifierVespeneGeyser", amount_percent);
    modify_resources("RichVespeneGeyser", amount_percent);
    modify_resources("ShakurasVespeneGeyser", amount_percent);
    modify_resources("SpacePlatformGeyser", amount_percent);
    modify_resources("VespeneGeyser", amount_percent);
    add_change(no_race, 0, "Gas", "%", "", 100, amount_percent);

    // TODO: for some reason it's able to read the starting workers, but trying to write them says
    // Catalog field 'StartingUnitArray[1].Count' could not be written (Core: access denied to required object or service)
    //for( i=0; i<16; i+=1 ) {
    //    info("Terr "+CatalogFieldValueGet(c_gameCatalogRace, "Terr", "StartingUnitArray[1].Count", i ));
    //    CatalogFieldValueSet(c_gameCatalogRace, "Terr", "StartingUnitArray[1].Count", i, IntToString(i) );
    //    info("Prot "+CatalogFieldValueGet(c_gameCatalogRace, "Prot", "StartingUnitArray[1].Count", i ));
    //    CatalogFieldValueSet(c_gameCatalogRace, "Prot", "StartingUnitArray[1].Count", i, IntToString(i) );
    //    info("Zerg "+CatalogFieldValueGet(c_gameCatalogRace, "Zerg", "StartingUnitArray[1].Count", i ));
    //    CatalogFieldValueSet(c_gameCatalogRace, "Zerg", "StartingUnitArray[1].Count", i, IntToString(i) );
    //}

    // TODO: randomize max supply, starting workers, maybe worker supply
}


int randomize_field(int cat, string scope, string entry, string field, string friendly_name, string val, int type, string field_type, int race_id, int num_fields );
int randomize_behavior(string entry, int race_id, int num_fields);
int randomize_effect(string entry, int race_id, int num_fields);
int randomize_weapon(string entry, int race_id, int num_fields);
int randomize_upgrade(string entry, int race_id, int num_fields);
int randomize_ability(string entry, int race_id, int num_fields);
int randomize_unit(string entry, int race_id, int num_fields);


int randomize_fields(int cat, string scope, string entry, string prefix, int race_id, int num_fields) {
    int i;
    int k;
    int slot;
    int slot2;
    int num;
    bool[1024] mask;
    int len;
    string field;
    string val;
    int type;
    string field_type;
    string friendly_name;

    debug("randomize_fields("+IntToString(cat)+", "+scope+", "+entry+", "+prefix+")");

    num = 0;
    for( i=0; num<num_fields && i<32; i+=1 ) {
        slot = GetRandomField(scope);
        if( slot == -1 ) {
            if( num==0 ) {
                debug(scope+" "+entry+" GetRandomField failed");
                note_add(scope+" GetRandomField failed");
            }
            return num;
        }
        if( mask[slot] ) { continue; }
        mask[slot] = true;

        field = randomized_fields[slot].name;
        type = randomized_fields[slot].type;
        
        if( randomized_fields[slot].is_array ) {
            len = CatalogFieldValueCount(cat, entry, prefix+field, default_player);
            field_type = CatalogFieldType(scope, prefix+field);
            for( k=0; num<num_fields && k<len; k+=1 ) {
                slot2 = RandomInt(0,len-1);
                friendly_name = randomized_fields[slot].friendly_name;
                if( type != type_struct ) {
                    val = CatalogFieldValueGet(cat, entry, prefix+field+"["+IntToString(slot2)+"]", default_player);
                    if( val == "" ) {
                        debug(scope+" "+entry+" failed CatalogFieldValueGet "+prefix+field+"["+IntToString(slot2)+"]");
                        continue;
                    }
                } else {
                    val = "";
                }
                num += randomize_field(cat, scope, entry, prefix+field+"["+IntToString(slot2)+"]", friendly_name, val, type, field_type, race_id, num_fields );
            }
        } else {
            friendly_name = randomized_fields[slot].friendly_name;
            if( type != type_struct ) {
                val = CatalogFieldValueGet(cat, entry, prefix+field, default_player);
                if( val == "" ) {
                    debug(scope+" "+entry+" failed CatalogFieldValueGet "+prefix+field);
                    continue;
                }
            } else {
                val = "";
            }
            if( friendly_name != "" && StringFind(friendly_name, ".", true) == 1 ) {
                friendly_name = CatalogFieldValueGet(cat, entry, prefix+friendly_name, default_player);
                if( friendly_name == "" ) {
                    debug(scope+" "+entry+" failed CatalogFieldValueGet friendly_name "+prefix+friendly_name);
                    continue;
                }
            }
            num += randomize_field(cat, scope, entry, prefix+field, friendly_name, val, type, "", race_id, num_fields );
        }
    }

    return num;
}


int randomize_behavior(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogBehavior;
    string scope;
    if( entry == "" ) {
        note_add("randomize_behavior empty entry");
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
    // Behavior PsiStorm is a CBehaviorBuff
}


int randomize_effect(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogEffect;
    string scope;
    if( entry == "" ) {
        note_add("randomize_effect empty entry");
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);

    // PsiStormPersistent is a CEffectCreatePersistent with a PeriodCount, PeriodEffectArray, PeriodicPeriodArray
    // PsiStormSearch is a CEffectEnumArea with a AreaArray[i].Radius, AreaArray[i].Effect
    // PsiStormApplyBehavior is a CEffectApplyBehavior with a Behavior == PsiStorm (a CBehaviorBuff)
    // PsiStormDamageInitial is a CEffectDamage with an Amount == 10, PsiStormDamage is the same

    // ArbiterMPRecallSet is a CEffectSet with an array EffectArray
    // ArbiterMPRecallTeleport is a CEffectTeleport with a PlacementRange of 15, Range of 1000
}


int randomize_weapon(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogWeapon;
    string scope;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);

    // CWeapon_DisplayEffect is where the damage is defined?

    // scopes
    // CWeaponLegacy has Period, Range, MinimumRange, MinScanRange, SCost Cost, 
    // InterceptorBeam is the only CWeaponStrafe with a Period, Range, Arc
}


int randomize_upgrade(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogUpgrade;
    string scope;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    // CUpgrade BattlecruiserBehemothReactor has <EffectArray Reference="Unit,Battlecruiser,EnergyStart" Value="25"/>
    // maybe if EffectArray[i].Operation is anything except Set, then it can be randomized
    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
}


int randomize_ability(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogAbil;
    string scope;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);

    // scopes
    // CAbilBuild
    // CAbilMorphPlacement
    // CAbilMove
    // CAbilStop
    // CAbilBuildable
    // CAbilQueue
    // CAbilArmMagazine
    // CAbilResearch
    // CAbilMorph
    // CAbilAttack
    // CAbilWarpable
    // CAbilEffectTarget
    // CAbilTrain
    // CAbilRally
    // CAbilEffectInstant
    // CAbilAugment
    // CAbilMerge
    // CAbilTransport
    // CAbilMergeable
    // CAbilBehavior
    // CAbilRedirectInstant
    // CAbilRedirectTarget

    // BarracksTechLabMorph is a CAbilMorph with InfoArray SAbilMorphInfo, and with Cost SCost
    // FactoryLand is a CAbilMorphPlacement with InfoArray SAbilMorphInfo, and with Cost SCost
    // FactoryTechLabResearch is a CAbilResearch with InfoArray SAbilResearchInfo
        // with InfoArray[3].Upgrade == TerranInfantryWeaponsLevel1, .Time=160, .Resource[Minerals/Vespene]
    // Rally is a CAbilRally with InfoArray SAbilRallyInfo
    // BuildNydusCanal is a CAbilBuild with InfoArray SAbilBuildInfo has [i].Unit for unit name and [i].Time for build time
    // TrainQueen is a CAbilTrain with InfoArray SAbilTrainInfo
    // ArmSiloWithNuke is a CAbilArmMagazine with InfoArray SAbilArmMagazineInfo, and with Cost SCost
    // WarpGateTrain is a CAbilWarpTrain with InfoArray SAbilWarpTrainInfo

    // GhostCloak is a CAbilBehavior with Cost SCost
        // has an array of structs named Cost, Cost[i].Charge, .Cooldown.TimeStart, .Cooldown.TimeUse, .Vital.Life, .Vital.Shields, .Vital.Energy, .VitalFraction
    
    // ArchonWarp is a CAbilMerge with InfoArray 
        // Info is a SAbilMergeInfo with Info.Resource.Minerals/Vespene, Info.Time, Info.Unit==Archon, Info.Cooldown, Info.Vital, Info.VitalFraction (seems to be same type as a CAbilBehavior.Cost)
    
    // Charge is a CAbilAugment with Cost SCost
        // has struct Cooldown (probably same type as Cooldown in CAbilBehavior)

    // TacNukeStrike is a CAbilEffectTarget with Cost SCost
        // has arrays for Effect, FinishTime (fixed), Range (fixed or maybe int?)
    
    // NydusCanalTransport is a CAbilTransport with InfoArray 
        // has MaxCargoCount, MaxCargoSize, Range, TotalCargoSpace, UnloadPeriod

    // BuildInProgress is a CAbilBuildable with InfoArray 
    // que5Addon is a CAbilQueue with InfoArray 
    // stop is a CAbilStop with InfoArray 
    // attack is a CAbilAttack with InfoArray 
    // move is a CAbilMove with InfoArray 
    // GhostHoldFire is a CAbilEffectInstant with InfoArray 
    // StimpackRedirect is a CAbilRedirectInstant with InfoArray 
    // AttackRedirect is a CAbilRedirectTarget with InfoArray 
    // Warpable is a CAbilWarpable with InfoArray 
    // Mergeable is a CAbilMergeable with InfoArray 
}


int randomize_unit(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogUnit;
    string scope = "CUnit";
    int i;
    int len;
    int slot;
    string val;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
}


void randomize_units(int faction, int changes_per_faction) {
    int cat = c_gameCatalogUnit;
    string scope = "CUnit";
    string entry;
    string cost_category;
    int num_data;
    int race_id;
    int i;
    int slot;

    // TODO: can we do 1 per frame or per tick?

    num_data = CatalogEntryCount(cat);

    for( i=1; i<=num_data; i+=1 ) {

        if( race_changes[faction*4 + terran].len >= changes_per_faction
            && race_changes[faction*4 + protoss].len >= changes_per_faction
            && race_changes[faction*4 + zerg].len >= changes_per_faction
        ) {
            break;
        }
        GameSetSeed( 5 + seed*3 + i*2713 + faction*3331);
        slot = RandomInt(1, num_data);

        entry = CatalogEntryGet(cat, slot);
        race_id = get_race_id(cat, scope, entry);
        if( race_id == no_race ) {
            continue;
        }
        race_id += faction*4;
        if( race_changes[race_id].len >= changes_per_faction ) {
            continue;
        }

        cost_category = CatalogFieldValueGet(cat, entry, "CostCategory", default_player);
        if( cost_category != "Army" && cost_category != "Technology" ) {
            continue;
        }

        randomize_unit(entry, race_id, RandomInt(1,changes_per_unit) );
    }

    GameSetSeed(seed);
}


int randomize_field(int cat, string scope, string entry, string field, string friendly_name, string val, int type, string field_type, int race_id, int num_fields ) {
    if( type == type_fixed ) {
        if( rando_field_fixed(cat, entry, field, friendly_name, race_id) ) {
            return 1;
        }
    }
    else if( type == type_int ) {
        if( rando_field_int(cat, entry, field, friendly_name, race_id) ) {
            return 1;
        }
    }
    else if( type == type_unit ) {
        return randomize_unit(val, race_id, num_fields);
    }
    else if( type == type_ability ) {
        return randomize_ability(val, race_id, num_fields);
    }
    else if( type == type_effect ) {
        return randomize_effect(val, race_id, num_fields);
    }
    else if( type == type_weapon ) {
        return randomize_weapon(val, race_id, num_fields);
    }
    else if( type == type_upgrade ) {
        return randomize_upgrade(val, race_id, num_fields);
    }
    else if( type == type_behavior ) {
        return randomize_behavior(val, race_id, num_fields);
    }
    else if( type == type_struct ) {
        if( field_type == "" ) {
            field_type = CatalogFieldType(scope, field);
        }
        return randomize_fields(cat, field_type, entry, field, race_id, num_fields);
    }
    else {
        if( field_type == "" ) {
            field_type = CatalogFieldType(CatalogEntryScope(cat, entry), field);
        }
        info(scope+" "+entry+" has "+field_type+" ("+IntToString(type)+") "+field+" "+friendly_name+", value: "+val );
        note_add(scope+" has "+field_type+" ("+IntToString(type)+") "+field+", value: "+val );
        return 0;
    }

    return 0;
}


void do_rando() {
    int i;
    bool seed_was_locked;

    notice("Randomizing with seed "+IntToString(seed)+", "+IntToString(num_factions)+" factions, "+IntToString(num_bans)+" bans, "+IntToString(changes_per_faction)+" changes per faction, "+FixedToString(min_percent,1)+"% minimum, "+FixedToString(max_percent,1)+"% maximum.");
    Wait(0.1, c_timeReal);

    seed_was_locked = GameIsSeedLocked();
    GameSetSeed(seed);

    randomize_economy();
    for( i=0; i < num_factions; i+=1 ) {
        Wait(0.1, c_timeReal);
        race_changes[i*4 + no_race].name = "General";
        race_changes[i*4 + terran].name = "Terran Faction "+IntToString(i+1);
        race_changes[i*4 + protoss].name = "Protoss Faction "+IntToString(i+1);
        race_changes[i*4 + zerg].name = "Zerg Faction "+IntToString(i+1);
        randomize_units(i, changes_per_faction);
    }

    notes_log();
    GameSetSeedLocked(seed_was_locked);
}


int create_continue_button(int dialog, string button_text, string callback) {
    int submit_button;

    submit_button = DialogControlCreate(dialog, c_triggerControlTypeButton);
    libNtve_gf_SetDialogItemText(submit_button, StringToText(button_text), PlayerGroupAll() );
    DialogControlSetSize(submit_button, PlayerGroupAll(), 400, 60);
    DialogControlSetPosition(submit_button, PlayerGroupAll(), c_anchorBottom, 0, 40);
    libNtve_gf_SetDialogItemTooltip(submit_button, StringToText(button_text), PlayerGroupAll());
    TriggerAddEventDialogControl(TriggerCreate(callback), c_playerAny, submit_button, c_triggerControlEventTypeClick);

    return submit_button;
}


int create_changes_list(int dialog) {
    int list;
    list = DialogControlCreate(dialog, c_triggerControlTypeListBox);
    DialogControlSetSize(list, PlayerGroupAll(), 1200, 800);
    DialogControlSetPosition(list, PlayerGroupAll(), c_anchorCenter, 0, 0);

    return list;
}


int create_ban_pick_button(int dialog, int list, string button_text, string callback) {
    int button;

    button = DialogControlCreate(dialog, c_triggerControlTypeButton);
    libNtve_gf_SetDialogItemText(button, StringToText(button_text), PlayerGroupAll() );
    DialogControlSetSize(button, PlayerGroupAll(), 200, 100);
    DialogControlSetPositionRelative( button, PlayerGroupAll(), c_anchorRight, list, c_anchorLeft, -50, 0 );
    libNtve_gf_SetDialogItemTooltip(button, StringToText(button_text), PlayerGroupAll());
    TriggerAddEventDialogControl(TriggerCreate(callback), c_playerAny, button, c_triggerControlEventTypeClick);

    return button;
}


int create_factions_dropdown(int dialog, int list, string callback) {
    int faction;
    int race;
    int dropdown;
    string name;

    // hide races that aren't in the game

    dropdown = DialogControlCreate(dialog, c_triggerControlTypePulldown);
    DialogControlSetSize( dropdown, PlayerGroupAll(), 500, 50 );
    DialogControlSetPositionRelative( dropdown, PlayerGroupAll(), c_anchorBottom, list, c_anchorTop, 0, 0 );

    DialogControlAddItem(dropdown, PlayerGroupAll(), StringToText("General Changes") );
    for( race=1; race<4; race+=1 ) {
        for( faction=0; faction<num_factions; faction+=1 ) {
            name = race_changes[faction*4 + race].name;
            DialogControlAddItem(dropdown, PlayerGroupAll(), StringToText(name) );
        }
    }

    TriggerAddEventDialogControl( TriggerCreate(callback), c_playerAny, dropdown, c_triggerControlEventTypeSelectionChanged );

    return dropdown;
}


void show_changes(int list, playergroup players, int race) {
    int i;
    string s;

    DialogControlRemoveAllItems(list, players);

    // TODO: zerg buildings count the cost of the drone...

    for( i=0; i<race_changes[race].len; i+=1 ) {
        s = race_changes[race].changes[i].entry;
        if( race_changes[race].changes[i].friendly_name != "" ) {
            s += " " + race_changes[race].changes[i].friendly_name;
        }
        s += " " + race_changes[race].changes[i].field;
        s += " changed from ";

        if( IntToFixed(FixedToInt(race_changes[race].changes[i].oldval)) == race_changes[race].changes[i].oldval
            && IntToFixed(FixedToInt(race_changes[race].changes[i].newval)) == race_changes[race].changes[i].newval ) {
            s += FixedToString(race_changes[race].changes[i].oldval,0)
                + " to "+FixedToString(race_changes[race].changes[i].newval,0);
        }
        else {
            s += FixedToString(race_changes[race].changes[i].oldval,5)
                + " to "+FixedToString(race_changes[race].changes[i].newval,5);
        }

        DialogControlAddItem(list, players, StringToText(s) );
    }
}


int get_player_faction_ban_slot(int player, int faction) {
    return faction + player*max_factions;
}


int get_player_num_bans(int player) {
    int faction;
    int num;
    for( faction=0; faction<max_factions*4; faction+=1 ) {
        if( players_bans[ get_player_faction_ban_slot(player, faction) ] ) {
            num+=1;
        }
    }
    return num;
}


bool faction_banned_for_player(int player, int faction) {
    int len;
    int i;
    int p;
    playergroup players;

    players = PlayerGroupAlliance(c_playerGroupEnemy, player);
    len = PlayerGroupCount(players);
    for( i=1; i<=len; i+=1 ) {
        p = PlayerGroupPlayer(players, i);

        if( players_bans[get_player_faction_ban_slot(p, faction)] ) {
            return true;
        }
    }
    return false;
}


int get_race_from_selected(int selected) {
    return selected % 4;
}


int get_selected_faction(int player, int dropdown) {
    int selected;
    int faction;
    int race;

    selected = DialogControlGetSelectedItem( dropdown, player );
    if( selected == 1 ) {
        selected = 0;// general changes
    }
    else {
        selected -= 2;
        faction = selected % num_factions;
        race = selected / num_factions + 1;
        selected = faction*4 + race;
    }
    info("dropdown_factions, faction: "+IntToString(faction)+", race: "+IntToString(race));
    return selected;
}


bool ban_button_click(bool testConds, bool runActions) {
    // TODO: show counter for remaining bans
    int selected;
    int player;

    player = EventPlayer();
    selected = get_selected_faction(player, factions_dropdown);

    if( players_bans[get_player_faction_ban_slot(player, selected)] ) {
        players_bans[get_player_faction_ban_slot(player, selected)] = false;
        notice( TextToString(PlayerName(player)) + " unbanned " + race_changes[selected].name );
        libNtve_gf_SetDialogItemText(ban_button, StringToText("Ban"), PlayerGroupSingle(player) );
        libNtve_gf_SetDialogItemTooltip(ban_button, StringToText("Ban"), PlayerGroupSingle(player) );
    } else {
        players_bans[get_player_faction_ban_slot(player, selected)] = true;
        notice( TextToString(PlayerName(player)) + " banned " + race_changes[selected].name );
        libNtve_gf_SetDialogItemText(ban_button, StringToText("Unban"), PlayerGroupSingle(player) );
        libNtve_gf_SetDialogItemTooltip(ban_button, StringToText("Unban"), PlayerGroupSingle(player) );
    }

    return true;
}


bool pick_button_click(bool testConds, bool runActions) {
    int selected;
    int player;

    player = EventPlayer();
    selected = get_selected_faction(player, factions_dropdown);

    players_picks[player] = selected;
    notice( TextToString(PlayerName(player)) + " chose " + race_changes[selected].name );
    DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), false);

    return true;
}


void pick_faction_dropdown(int player, int selected, int race) {
    if( faction_banned_for_player(player, selected) ) {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), false);
        return;
    }

    if( players_picks[player] == selected ) {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), false);
        return;
    }

    if( race == terran && PlayerRace(player) == "Terr" ) {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), true);
    } else if( race == protoss && PlayerRace(player) == "Prot" ) {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), true);
    } else if( race == zerg && PlayerRace(player) == "Zerg" ) {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), true);
    }
    else {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), false);
    }
}


void ban_faction_dropdown(int player, int selected, int race) {
    if( race == no_race ) {
        DialogControlSetEnabled(ban_button, PlayerGroupSingle(player), false);
        return;
    }

    if( players_bans[get_player_faction_ban_slot(player, selected)] ) {
        libNtve_gf_SetDialogItemText(ban_button, StringToText("Unban"), PlayerGroupSingle(player) );
        libNtve_gf_SetDialogItemTooltip(ban_button, StringToText("Unban"), PlayerGroupSingle(player) );
        DialogControlSetEnabled(ban_button, PlayerGroupSingle(player), true);
        return;
    }
    else {
        libNtve_gf_SetDialogItemText(ban_button, StringToText("Ban"), PlayerGroupSingle(player) );
        libNtve_gf_SetDialogItemTooltip(ban_button, StringToText("Ban"), PlayerGroupSingle(player) );
    }

    if( get_player_num_bans(player) > num_bans ) {
        DialogControlSetEnabled(ban_button, PlayerGroupSingle(player), false);
    } else {
        DialogControlSetEnabled(ban_button, PlayerGroupSingle(player), true);
    }
}


bool dropdown_factions(bool testConds, bool runActions) {
    int selected;
    int race;
    int dropdown;
    int dialog;
    int player;

    dropdown = EventDialogControl();
    dialog = DialogControlGetDialog(dropdown);
    player = EventPlayer();
    selected = get_selected_faction(player, dropdown);
    race = get_race_from_selected(selected);
    show_changes(changes_list, PlayerGroupSingle(EventPlayer()), selected );

    if( dialog == dialog_pick_faction ) {
        pick_faction_dropdown(player, selected, race);
    }
    else if( dialog == dialog_bans ) {
        ban_faction_dropdown(player, selected, race);
    }
    return true;
}


void clear_waiting() {
    int i;
    for( i=0; i<16; i+=1 ) {
        players_waiting[i] = false;
    }
}


bool is_waiting(int player, int button) {
    int i;
    int num_players_waiting;
    playergroup players;

    players_waiting[player] = true;

    players = GetPlayersOfType(c_playerTypeUser);

    DialogControlSetEnabled(button, PlayerGroupSingle(player), false);
    libNtve_gf_SetDialogItemText(button, StringToText("Waiting For Other Players"), PlayerGroupSingle(player) );
    libNtve_gf_SetDialogItemTooltip(button, StringToText("Waiting For Other Players"), PlayerGroupSingle(player) );

    for( i=0; i<16; i+=1 ) {
        if( PlayerGroupHasPlayer(players, i) && players_waiting[i] ) {
            num_players_waiting += 1;
        }
    }

    if( num_players_waiting < PlayerGroupCount(players) ) {
        return true;
    }

    clear_waiting();

    return false;
}


void apply_changes_player(int player) {
    int faction;

    faction = players_picks[player];
    // TODO: ensure null picks don't pick a banned faction, give them a random faction for more fun AI FFAs
    // TODO: ensure picked correct race

    if( faction == 0 ) {
        if( PlayerRace(player) == "Terr" ) {
            faction = faction*4 + terran;
        } else if( PlayerRace(player) == "Prot" ) {
            faction = faction*4 + protoss;
        } else if( PlayerRace(player) == "Zerg" ) {
            faction = faction*4 + zerg;
        } else {
            err("unknown PlayerRace("+IntToString(player)+" == "+PlayerRace(player));
        }
    }
    apply_changes(faction, player);
    info("EventPlayer() == " + IntToString(player) );
}


void start_game() {
    int i;
    int len;
    playergroup players;

    TriggerDestroy(dialog_timeout);

    players = PlayerGroupActive();
    len = PlayerGroupCount(players);
    for( i=1; i<=len; i+=1 ) {
        apply_changes_player( PlayerGroupPlayer(players, i) );
    }

    DialogSetVisible(dialog_pick_faction, PlayerGroupAll(), false);
    DialogDestroy(dialog_pick_faction);

    libNtve_gf_HideGameUI( true, PlayerGroupAll() );
    for( i=0; i<16; i+=1 ) {// TODO: active players only?
        CameraLockInput(i, false);
    }
    GameSetGlobalTimeScale(1);
}


bool start_game_timeout(bool testConds, bool runActions) {
    clear_waiting();
    start_game();
    return true;
}


bool start_game_button_pressed(bool testConds, bool runActions) {
    int i;
    int faction;
    int player;
    int dialog;
    int button;

    player = EventPlayer();
    button = EventDialogControl();
    dialog = DialogControlGetDialog(button);

    DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), false);

    if( is_waiting(player, button) ) {
        return true;
    }

    start_game();
    return true;
}


int create_dialog_pick_faction() {
    playergroup players;
    int button;

    players = PlayerGroupAll();

    dialog_pick_faction = DialogCreate(500, 500, c_anchorCenter, 0, 0, true);
    DialogSetTitle(dialog_pick_faction, StringToText(dialog_title) );
    DialogSetFullscreen(dialog_pick_faction, true);

    create_continue_button(dialog_pick_faction, "Start Game", "start_game_button_pressed");
    
    TriggerDestroy(dialog_timeout);
    dialog_timeout = TriggerCreate("start_game_timeout");
    TriggerAddEventTimeElapsed( dialog_timeout, 120, c_timeReal );

    changes_list = create_changes_list(dialog_pick_faction);

    factions_dropdown = create_factions_dropdown(dialog_pick_faction, changes_list, "dropdown_factions");

    pick_button = create_ban_pick_button(dialog_pick_faction, changes_list, "Pick", "pick_button_click");
    DialogControlSetEnabled(pick_button, players, false);

    DialogControlAddItem(changes_list, players, StringToText("Select a race/faction to see the changes") );
    DialogControlAddItem(changes_list, players, StringToText("Click on the Pick button to select that faction to play as") );

    DialogSetVisible(dialog_pick_faction, players, true);

    return dialog_pick_faction;
}


void start_pick_factions() {
    clear_waiting();
    DialogSetVisible(dialog_bans, PlayerGroupAll(), false);
    DialogDestroy(dialog_bans);

    create_dialog_pick_faction();
}


bool ban_factions_timeout(bool testConds, bool runActions) {
    start_pick_factions();
    return true;
}


bool bans_done_button_pressed(bool testConds, bool runActions) {
    int i;
    int player;
    int num_players_waiting;
    playergroup players;
    int button;

    DialogControlSetEnabled(ban_button, PlayerGroupSingle(player), false);

    if( is_waiting(EventPlayer(), EventDialogControl()) ) {
        return true;
    }

    start_pick_factions();

    return true;
}


int create_dialog_bans() {
    int width;
    int height;
    //int race;
    playergroup players;
    int button;

    players = PlayerGroupAll();

    // TODO: bans remaining 2 / 3
    // ban/unban button
    // timer
    // picks screen
    // create wait screens in advance for every player, show them 1 player at a time

    dialog_bans = DialogCreate(500, 500, c_anchorCenter, 0, 0, true);
    DialogSetTitle(dialog_bans, StringToText(dialog_title) );
    DialogSetFullscreen(dialog_bans, true);

    // TODO: how to get screen size? these seem to return 500, 500 even though I set the dialog to fullscreen
    width = DialogGetWidth(dialog_bans);
    height = DialogGetHeight(dialog_bans);

    changes_list = create_changes_list(dialog_bans);

    factions_dropdown = create_factions_dropdown(dialog_bans, changes_list, "dropdown_factions");

    ban_button = create_ban_pick_button(dialog_bans, changes_list, "Ban", "ban_button_click");
    DialogControlSetEnabled(ban_button, players, false);

    DialogControlAddItem(changes_list, players, StringToText("Select a race/faction to see the changes") );
    DialogControlAddItem(changes_list, players, StringToText("Click on the Ban button to disallow your opponents from picking that faction") );

    create_continue_button(dialog_bans, "Continue", "bans_done_button_pressed");

    TriggerDestroy(dialog_timeout);
    dialog_timeout = TriggerCreate("ban_factions_timeout");
    TriggerAddEventTimeElapsed( dialog_timeout, 120, c_timeReal );

    DialogSetVisible(dialog_bans, players, true);

    return dialog_bans;
}


bool start_rando_button_pressed(bool testConds, bool runActions) {
    string sseed;
    string snum_factions;
    string snum_bans;
    string schanges_per_faction;
    //string schanges_per_unit;
    string smin_percent;
    string smax_percent;
    int loading_screen;
    int loading_text;
    int num_players;
    int max_bans;

    TriggerDestroy(dialog_timeout);

    sseed = libNtve_gf_DialogItemEditValue(seed_editbox, default_player);
    if( sseed != "" ) {
        seed = StringToInt(sseed);
    }

    num_players = PlayerGroupCount(PlayerGroupActive());
    snum_factions = libNtve_gf_DialogItemEditValue(num_factions_editbox, default_player);
    if( snum_factions != "" ) {
        num_factions = StringToInt(snum_factions);
        if( num_factions > max_factions ) {
            num_factions = max_factions;
        }
        if( num_factions < 1 ) {
            num_factions = 1;
        }
    }

    snum_bans = libNtve_gf_DialogItemEditValue(num_bans_editbox, default_player);
    if(num_players > 1 && num_factions > 1 ) {
        max_bans = num_factions / (num_players-1);
    } else {
        max_bans = num_factions - 1;
    }
    if( snum_bans != "" ) {
        num_bans = StringToInt(snum_bans);
        if( num_bans > max_bans ) {
            num_bans = max_bans;
        }
        if( num_bans < 0 ) {
            num_bans = 0;
        }
    }

    schanges_per_faction = libNtve_gf_DialogItemEditValue(changes_per_faction_editbox, default_player);
    if( schanges_per_faction != "" ) {
        changes_per_faction = StringToInt(schanges_per_faction);
        if( changes_per_faction > 200 ) {
            changes_per_faction = 200;
        }
        if( changes_per_faction < 1 ) {
            changes_per_faction = 1;
        }
    }

    smin_percent = libNtve_gf_DialogItemEditValue(min_percent_editbox, default_player);
    if( smin_percent != "" ) {
        min_percent = StringToFixed(smin_percent);
    }

    smax_percent = libNtve_gf_DialogItemEditValue(max_percent_editbox, default_player);
    if( smax_percent != "" ) {
        max_percent = StringToFixed(smax_percent);
    }

    DialogSetVisible(dialog_start, PlayerGroupAll(), false);
    DialogDestroy(dialog_start);

    DialogSetVisible(dialog_wait, PlayerGroupAll(), false);
    DialogDestroy(dialog_wait);

    loading_screen = DialogCreate(500, 500, c_anchorCenter, 0, 0, true);
    DialogSetTitle(loading_screen, StringToText(dialog_title) );
    DialogSetFullscreen(loading_screen, true);

    loading_text = DialogControlCreate(loading_screen, c_triggerControlTypeLabel);
    DialogControlSetSize(loading_text, PlayerGroupAll(), 300, 300);
    DialogControlSetPosition(loading_text, PlayerGroupAll(), c_anchorCenter, 0, 0);
    libNtve_gf_SetDialogItemText( loading_text, StringToText("Please wait while randomizing, this might take a few seconds..."), PlayerGroupAll() );
    libNtve_gf_SetDialogItemTooltip( loading_text, StringToText("Please wait while randomizing, this might take a few seconds..."), PlayerGroupAll() );

    DialogSetVisible(loading_screen, PlayerGroupAll(), true);

    do_rando();

    DialogSetVisible(loading_screen, PlayerGroupAll(), false);
    DialogDestroy(loading_screen);

    create_dialog_bans();
    return true;
}


int create_edit_box_with_label(int dialog, playergroup players, string defaulttext, string labeltext, string tooltip, int row) {
    int label;
    int editbox;
    int y;
    int row_height;

    row_height = 80;
    y = row*row_height - 3*row_height;

    editbox = DialogControlCreate(dialog, c_triggerControlTypeEditBox);
    DialogControlSetSize(editbox, players, 300, 50);
    DialogControlSetPosition(editbox, players, c_anchorCenter, 150, y);
    libNtve_gf_SetDialogItemTooltip(editbox, StringToText(tooltip), players);
    libNtve_gf_SetDialogItemEditorValue(editbox, defaulttext, players);

    label = DialogControlCreate(dialog, c_triggerControlTypeLabel);
    DialogControlSetSize(label, players, 300, 50);
    libNtve_gf_SetDialogItemText(label, StringToText(labeltext), players );
    libNtve_gf_SetDialogItemTooltip(label, StringToText(tooltip), players);

    DialogControlSetPositionRelative(label, players, c_anchorRight, editbox, c_anchorLeft, 0, 15);
    return editbox;
}


int create_dialog_settings() {
    playergroup players;
    int num_players;

    players = PlayerGroupSingle(default_player);

    num_players = PlayerGroupCount(PlayerGroupActive());
    // TODO: timeouts for dialogs with countdown
    if( num_players > 4 ) {
        num_bans = 0;
        num_factions = 3;
    }
    else {
        num_bans = 1;
        num_factions = MaxI(3, num_players+1);
    }

    dialog_start = DialogCreate(500, 500, c_anchorCenter, 0, 0, true);
    DialogSetTitle(dialog_start, StringToText(dialog_title) );
    DialogSetFullscreen(dialog_start, true);

    seed_editbox = create_edit_box_with_label(dialog_start, players, IntToString(seed), "Seed: ", "The seed used for randomization", 0);
    num_factions_editbox = create_edit_box_with_label(dialog_start, players, IntToString(num_factions), "Factions: ", "How many factions to generate for each race", 1);
    num_bans_editbox = create_edit_box_with_label(dialog_start, players, IntToString(num_bans), "Bans: ", "How many bans each player can use", 2);

    changes_per_faction_editbox = create_edit_box_with_label(dialog_start, players, IntToString(changes_per_faction), "Changes per faction: ", "How many things to change for each faction", 3);
    //changes_per_unit_editbox = create_edit_box_with_label(dialog_start, players, IntToString(changes_per_unit), "Changes per unit: ", "Maximum number of things to change for each unit", 4);

    min_percent_editbox = create_edit_box_with_label(dialog_start, players, FixedToString(min_percent,0), "Minimum Value %: ", "The lowest each stat can be changed to", 4);
    max_percent_editbox = create_edit_box_with_label(dialog_start, players, FixedToString(max_percent,0), "Maximum Value %: ", "The highest each stat can be changed to", 5);

    create_continue_button(dialog_start, "Continue", "start_rando_button_pressed");

    dialog_timeout = TriggerCreate("start_rando_button_pressed");
    TriggerAddEventTimeElapsed( dialog_timeout, 60, c_timeReal );

    DialogSetVisible(dialog_start, players, true);

    return dialog_start;
}


int create_dialog_wait_settings() {
    playergroup players;
    int label;
    
    players = PlayerGroupCopy(PlayerGroupAll());// not sure if it needs to be copied
    PlayerGroupRemove(players, default_player);

    dialog_wait = DialogCreate(500, 500, c_anchorCenter, 0, 0, true);
    DialogSetTitle(dialog_wait, StringToText(dialog_title) );
    DialogSetFullscreen(dialog_wait, true);

    label = DialogControlCreate(dialog_wait, c_triggerControlTypeLabel);
    DialogControlSetSize(label, players, 100, 50);
    DialogControlSetPosition(label, players, c_anchorCenter, 0, 0);
    libNtve_gf_SetDialogItemText(label, StringToText("Waiting for host to choose settings..."), players );
    libNtve_gf_SetDialogItemTooltip(label, StringToText("Waiting for host to choose settings..."), players);

    DialogSetVisible(dialog_wait, players, true);
    return dialog_wait;
}


void create_dialog_start() {
    int list;
    int i;
    int race;
    string s;
    int width;
    int height;
    int seed_label;
    int submit_button;

    for( i=0; i<16; i+=1 ) {// TODO: active players only?
        CameraLockInput(i, true);
    }

    GameSetGlobalTimeScale(0);
    libNtve_gf_HideGameUI( false, PlayerGroupAll() );

    create_dialog_settings();
    create_dialog_wait_settings();
}


void main () {
    int oldseed;
    int i;

    seed=1337;
    seed = RandomInt(1, 999999);
    min_percent = 50;
    max_percent = 150;
    num_factions = 3;
    num_bans = 1;
    changes_per_faction = 20;
    changes_per_unit = 2;
    
    // CUnit
    AddRandomizedField("CUnit", type_int, "CostResource[Minerals]");
    AddRandomizedField("CUnit", type_int, "CostResource[Vespene]");
    AddRandomizedField("CUnit", type_int, "Food");
    AddRandomizedField("CUnit", type_int, "LifeMax");
    AddRandomizedField("CUnit", type_int, "ShieldsMax");
    AddRandomizedField("CUnit", type_int, "EnergyMax");
    //AddRandomizedField("CUnit", type_fixed, "Acceleration");
    AddRandomizedField("CUnit", type_fixed, "Speed");
    AddRandomizedFieldArray("CUnit", type_struct, "AbilArray");
    AddRandomizedFieldArray("CUnit", type_struct, "WeaponArray");

    // Weapons
    AddRandomizedField("CWeaponLegacy", type_fixed, "Range");
    AddRandomizedField("CWeaponLegacy", type_fixed, "Period");
    AddRandomizedField("CWeaponLegacy", type_effect, "DisplayEffect");
    AddRandomizedField("CWeaponStrafe", type_fixed, "Range");
    AddRandomizedField("CWeaponStrafe", type_fixed, "Period");
    AddRandomizedField("CWeaponStrafe", type_effect, "DisplayEffect");

    // Effects
    AddRandomizedField("CEffectDamage", type_int, "Amount");
    AddRandomizedField("CEffectCreatePersistent", type_effect, "InitialEffect");
    AddRandomizedField("CEffectCreatePersistent", type_effect, "AINotifyEffect");
    AddRandomizedField("CEffectCreatePersistent", type_int, "PeriodCount");
    AddRandomizedFieldArray("CEffectCreatePersistent", type_effect, "PeriodicEffectArray");
    AddRandomizedFieldArray("CEffectCreatePersistent", type_fixed, "PeriodicPeriodArray");
    AddRandomizedFieldArray("CEffectEnumArea", type_struct, "AreaArray");
    AddRandomizedField("CEffectApplyBehavior", type_behavior, "Behavior");
    AddRandomizedFieldArray("CEffectSet", type_behavior, "EffectArray");
    AddRandomizedField("CEffectTeleport", type_behavior, "PlacementRange");
    AddRandomizedField("CEffectTeleport", type_behavior, "Range");

    // Abilities
    AddRandomizedFieldArray("CAbilBuild", type_struct, "InfoArray");
    AddRandomizedField("CAbilBuild", type_int, "Range");
    AddRandomizedFieldArray("CAbilBuild", type_effect, "EffectArray");

    AddRandomizedFieldArray("CAbilResearch", type_struct, "InfoArray");

    AddRandomizedFieldArray("CAbilEffectInstant", type_effect, "Effect");
    AddRandomizedField("CAbilEffectInstant", type_effect, "AINotifyEffect");
    AddRandomizedFieldArray("CAbilEffectInstant", type_struct, "Cost");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "CastIntroTime");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "PrepTime");
    AddRandomizedField("CAbilEffectInstant", type_fixed, "AutoCastRange");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "Range");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "FinishTime");
    AddRandomizedField("CAbilEffectInstant", type_int, "Arc");

    AddRandomizedFieldArray("CAbilTrain", type_struct, "InfoArray");

    AddRandomizedFieldArray("CAbilArmMagazine", type_struct, "InfoArray");
    AddRandomizedField("CAbilArmMagazine", type_struct, "Cost");

    AddRandomizedFieldArray("CAbilWarpTrain", type_struct, "InfoArray");

    //AddRandomizedFieldArray("CAbilMorph", type_struct, "InfoArray");
    AddRandomizedField("CAbilMorph", type_struct, "Cost");

    //AddRandomizedFieldArray("CAbilMorphPlacement", type_struct, "InfoArray");
    AddRandomizedField("CAbilMorphPlacement", type_struct, "Cost");

    AddRandomizedField("CAbilBehavior", type_struct, "Cost");
    AddRandomizedFieldArray("CAbilBehavior", type_behavior, "BehaviorArray");

    AddRandomizedField("CAbilMerge", type_struct, "Info");

    AddRandomizedField("CAbilAugment", type_struct, "Cost");
    AddRandomizedField("CAbilAugment", type_effect, "Effect");

    AddRandomizedFieldArray("CAbilEffectTarget", type_struct, "Cost");
    AddRandomizedFieldArray("CAbilEffectTarget", type_effect, "Effect");
    AddRandomizedFieldArray("CAbilEffectTarget", type_int, "FinishTime");
    AddRandomizedFieldArray("CAbilEffectTarget", type_int, "Range");

    //AddRandomizedField("CAbilTransport", type_int, "MaxCargoCount");
    //AddRandomizedField("CAbilTransport", type_int, "MaxCargoSize");
    AddRandomizedField("CAbilTransport", type_int, "TotalCargoSpace");
    AddRandomizedField("CAbilTransport", type_fixed, "UnloadPeriod");
    //AddRandomizedField("CAbilTransport", type_int, "MaxUnloadRange");
    AddRandomizedField("CAbilTransport", type_int, "Range");
    //AddRandomizedField("CAbilTransport", type_int, "SearchRadius");

    // Behaviors
    AddRandomizedField("CBehaviorBuff", type_effect, "InitialEffect");
    AddRandomizedField("CBehaviorBuff", type_effect, "PeriodicEffect");
    AddRandomizedField("CBehaviorBuff", type_effect, "AINotifyEffect");
    AddRandomizedFieldArray("CBehaviorBuff", type_effect, "PeriodicDisplayEffect");
    AddRandomizedField("CBehaviorBuff", type_fixed, "Duration");
    AddRandomizedField("CBehaviorBuff", type_fixed, "Period");
    AddRandomizedField("CBehaviorBuff", type_struct, "Cost");

    // Upgrades
    //AddRandomizedFieldArray("CUpgrade", type_unknown, "EffectArray");

    // structs
    AddRandomizedField("SCost", type_int, ".Cooldown.TimeStart");
    AddRandomizedField("SCost", type_int, ".Cooldown.TimeUse");
    AddRandomizedField("SCost", type_int, ".Resource[Minerals]");
    AddRandomizedField("SCost", type_int, ".Resource[Vespene]");
    AddRandomizedField("SCost", type_int, ".Vital[Life]");
    AddRandomizedField("SCost", type_int, ".Vital[Shields]");
    AddRandomizedField("SCost", type_int, ".Vital[Energy]");

    AddRandomizedFieldFriendlyName("SAbilBuildInfo", type_int, ".Time", ".Unit");
    CopyRandomizedFields("SCost", "SAbilBuildInfo", ".Unit");

    AddRandomizedFieldFriendlyName("SAbilResearchInfo", type_int, ".Time", ".Upgrade");
    AddRandomizedField("SAbilResearchInfo", type_upgrade, ".Upgrade");
    CopyRandomizedFields("SCost", "SAbilResearchInfo", ".Upgrade");

    AddRandomizedFieldFriendlyName("SAbilTrainInfo", type_int, ".Time", ".Unit[0]");
    AddRandomizedField("SAbilTrainInfo", type_effect, ".Effect");
    CopyRandomizedFields("SCost", "SAbilTrainInfo", ".Unit[0]");// TODO: idk if this is needed

    AddRandomizedField("SUnitAbilData", type_ability, ".Link");
    AddRandomizedField("SUnitWeaponData", type_weapon, ".Link");

    AddRandomizedFieldFriendlyName("SAbilArmMagazineInfo", type_int, ".Time", ".Unit");
    CopyRandomizedFields("SCost", "SAbilArmMagazineInfo", ".Unit");

    AddRandomizedFieldFriendlyName("SAbilWarpTrainInfo", type_int, ".Time", ".Unit");
    CopyRandomizedFields("SCost", "SAbilWarpTrainInfo", ".Unit");

    AddRandomizedField("SEffectEnumArea", type_effect, ".Effect");
    AddRandomizedField("SEffectEnumArea", type_fixed, ".Radius");

    create_dialog_start();
}
