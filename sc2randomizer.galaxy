include "TriggerLibs/NativeLib"

// https://marketplace.visualstudio.com/items?itemName=maptz.regionfolder regionfolder.collapseAllRegions
// #region Globals
fixed min_percent;
fixed max_percent;
fixed min_resources;
fixed max_resources;
int seed;
const int max_factions = 8;
int num_factions;
int num_bans;
int changes_per_faction;
int changes_per_unit;

bool[max_factions * 4 * 16] players_bans;
int[16] players_picks;
bool[16] players_waiting;

const string dialog_title = "StarCraft 2 Randomizer Alpha https://discord.gg/P38gdMSNZt";
const int default_player = 1;
int dialog_start;
int seed_editbox;
int num_factions_editbox;
int num_bans_editbox;
int changes_per_faction_editbox;
int changes_per_unit_editbox;
int min_percent_editbox;
int max_percent_editbox;
int dialog_bans;
int changes_list;
int dialog_wait;
int dialog_pick_faction;
int ban_button;
int pick_button;
int factions_dropdown;
int submit_button;
trigger dialog_timeout;

struct Change {
    int cat;
    string entry;
    string field;
    string friendly_name;
    fixed oldval;
    fixed newval;
};

struct RaceChanges {
    string name;
    Change[128] changes;
    int len;
};
const int no_race=0;
const int terran=1;
const int protoss=2;
const int zerg=3;
RaceChanges[max_factions *4] race_changes;

struct RandomizedField {
    //int cat;
    int type;
    string scope;
    string name;
    string friendly_name;
    bool is_array;
};
RandomizedField[256] randomized_fields;
const int type_unknown = 0;
const int type_fixed = 1;
const int type_int = 2;
// scopes
const int type_unit = 3;
const int type_ability = 4;
const int type_effect = 5;
const int type_weapon = 6;
const int type_upgrade = 7;
const int type_behavior = 8;

const int type_struct = 100;

string[256] randomized_units;// defensive structures go here? so the weapon and HP gets randomized too?
int num_randomized_units;
string[128] randomized_buildings;
int num_randomized_buildings;
string[128] linked_units;
int num_linked_units;

const int precision = 4;
// #endregion

// #region Utility Functions
fixed rng(fixed min, fixed max) {
    return RandomFixed(min, max);
}

fixed randomize_min_max(fixed val, fixed min, fixed max) {
    fixed percent;
    // probably should make all changes far away from 100%, since there will be few things changed
    percent = rng(min, max);
    if( (percent - min) < (max - percent) ) {
        percent = (percent+min) / 2.0;
    } else {
        percent = (percent+max) / 2.0;
    }
    return val * (percent / 100.0);
}

fixed randomize(fixed val) {
    return randomize_min_max(val, min_percent, max_percent);
}


void debug(string message)
{
    text t;
    t = StringToText(message);
    TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    //t = StringToText("debug: ") + t;
    //UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}

void info(string message)
{
    text t;
    t = StringToText(message);
    TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    //t = StringToText("info: ") + t;
    //UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}

void notice(string message)
{
    text t;
    t = StringToText(message);
    TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}

void warning(string message)
{
    text t;
    t = StringToText(message);
    TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    //t = StringToText("warning: ") + t;
    //UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}

void err(string message)
{
    text t;
    t = StringToText(message);
    TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    t = StringToText("error: ") + t;
    UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}

void fatal(string message)
{
    text t;
    t = StringToText(message);
    TriggerDebugOutput(1, t, false );
    //libNtve_gf_UIErrorMessage( PlayerGroupAll(), t, SoundLink("UI_GenericError", -1));
    t = StringToText("fatal error: ") + t;
    UIDisplayMessage(PlayerGroupAll(), c_messageAreaChat, t);
}

string SPlayerName(int player)
{
    return TextToString(PlayerName(player));
}


int find_change(int self, string entry, string field)
{
    int i;
    for( i=0; i < race_changes[self].len; i+=1 ) {
        if( race_changes[self].changes[i].entry == entry && race_changes[self].changes[i].field == field ) {
            return i;
        }
    }
    return -1;
}

bool add_change(int self, int cat, string entry, string field, string friendly_name, fixed oldval, fixed newval)
{
    int len;

    len = race_changes[self].len;
    if( len >= 256 ) {
        err("add_change failed with "+entry+" "+field+" changing from "+FixedToString(oldval,precision)+" to "+FixedToString(newval,precision));
        return false;
    }
    race_changes[self].changes[len].cat = cat;
    race_changes[self].changes[len].entry = entry;
    race_changes[self].changes[len].field = field;
    race_changes[self].changes[len].friendly_name = friendly_name;
    race_changes[self].changes[len].oldval = oldval;
    race_changes[self].changes[len].newval = newval;
    race_changes[self].len += 1;

    debug("add_change with "+entry+" "+field+" "+friendly_name+" changing from "+FixedToString(oldval,precision)+" to "+FixedToString(newval,precision));

    return true;
}


playergroup GetPlayersOfType(int type)
{
    playergroup players;
    int i;

    players = PlayerGroupCopy(PlayerGroupActive());
    for( i=0; i<16; i+=1 ) {
        if( PlayerGroupHasPlayer(players, i) && PlayerType(i) != type ) {
            PlayerGroupRemove(players, i);
        }
    }

    return players;
}

string[100] notes;
bool note_add(string val)
{
    int i;
    for( i=0; i<100; i+=1 ) {
        if( notes[i] == val ) {
            return false;
        }
        if( notes[i] == "" ) {
            info("note_add "+val);
            notes[i] = val;
            return true;
        }
    }
    return false;
}

void notes_log()
{
    int i;
    for( i=0; i<100; i+=1 ) {
        if( notes[i] == "" ) {
            continue;
        }
        TriggerDebugOutput(1, StringToText(notes[i]), false );
    }
}

int get_race_id(int cat, string scope, string entry) {
    string EditorCategories;
    string race;

    if( CatalogFieldExists(scope, "EditorCategories") ) {
        EditorCategories = CatalogFieldValueGet(cat, entry, "EditorCategories", default_player);
        if( ! StringContains(EditorCategories, "ObjectFamily:Melee", c_stringAnywhere, c_stringCase) ) {
            return no_race;
        }
    } else {
        EditorCategories = "";
    }

    if( CatalogFieldExists(scope, "Race") ) {
        race = "Race:" + CatalogFieldValueGet(cat, entry, "Race", default_player);
    }
    else {
        race = EditorCategories;
    }

    if( StringContains(race, "Race:Terr", c_stringAnywhere, c_stringCase) ) {
        return terran;
    }
    else if( StringContains(race, "Race:Prot", c_stringAnywhere, c_stringCase) ) {
        return protoss;
    }
    else if( StringContains(race, "Race:Zerg", c_stringAnywhere, c_stringCase) ) {
        return zerg;
    }
    
    return no_race;
}
// #endregion

// #region Catalog Data Functions
bool set_field_string(int cat, string entry, string field, string value)
{
    if( ! CatalogFieldValueSet(cat, entry, field, default_player, value) ) {
        return false;
    }
    return true;
}

bool set_field_string_player(int player, int cat, string entry, string field, string value)
{
    if( ! CatalogFieldValueSet(cat, entry, field, player, value) ) {
        return false;
    }
    return true;
}

bool set_field_string_all(int cat, string entry, string field, string value)
{
    playergroup allplayers;
    int player;
    int num_players;
    int i;

    allplayers = PlayerGroupAll();
    num_players = PlayerGroupCount(allplayers);
    for( i=1; i<=num_players; i+=1 ) {
        player = PlayerGroupPlayer( allplayers, i );
        if( ! CatalogFieldValueSet(cat, entry, field, player, value) ) {
            return false;
        }
    }
    return true;
}


bool set_field_fixed(int cat, string entry, string field, fixed value)
{
    if( ! libNtve_gf_CatalogFieldValueSetAsReal(cat, entry, field, default_player, value) ) {
        return false;
    }
    return true;
}

bool set_field_fixed_all(int cat, string entry, string field, fixed value)
{
    playergroup allplayers;
    int player;
    int num_players;
    int i;
    allplayers = PlayerGroupAll();
    num_players = PlayerGroupCount(allplayers);
    for( i=1; i<=num_players; i+=1 ) {
        player = PlayerGroupPlayer( allplayers, i );
        if( ! libNtve_gf_CatalogFieldValueSetAsReal(cat, entry, field, player, value) ) {
            return false;
        }
    }
    return true;
}


string apply_change_entry(int player, int cat, string entry, string field, fixed oldf, fixed f)
{
    string val;
    string oldval;

    if( IntToFixed(FixedToInt(f)) == f ) {
        val = IntToString(FixedToInt(f));
        oldval = IntToString(FixedToInt(oldf));
    }
    else {
        val = FixedToString(f,precision);
        oldval = FixedToString(oldf, precision);
    }
    if( ! set_field_string_player(player, cat, entry, field, val ) ) {
        err(entry+" "+field+" failed to set to "+val);
    }

    if( field == "LifeMax" ) {// TODO: maybe need a list of linked values to keep proportional instead of hardcoded
        if( ! set_field_string_player(player, cat, entry, "LifeStart", val ) ) {
            err(entry+" LifeStart failed to set to "+val);
        }
    }
    if( field == "ShieldsMax" ) {
        if( ! set_field_string_player(player, cat, entry, "ShieldsStart", val ) ) {
            err(entry+" ShieldsStart failed to set to "+val);
        }
    }

    return entry+" "+field+" changed from "+oldval+" to "+val;
}


void apply_linkage(int player, int cat, string parent, string entry, string field, fixed oldf, fixed f)
{
    fixed percent;
    fixed oldval;
    fixed newval;

    percent = f / oldf;

    oldval = libNtve_gf_CatalogFieldValueGetAsReal(cat, entry, field, player);
    newval = oldval * percent;

    if( oldval == oldf ) {
        newval = f;
    }
    else if( IntToFixed(FixedToInt(f)) == f ) {
        newval = IntToFixed(FixedToInt(newval));
    }

    info( "apply_linkage("+parent+") "+FixedToString(percent*100.0, precision)+"% - " + apply_change_entry(player, cat, entry, field, oldval, newval) );
}


void apply_changes(int r, int player)
{
    int i;
    int k;
    string entry;
    string message;

    message = SPlayerName(player) + " with " + race_changes[r].name + ": ";
    info(message);
    message = "- ";

    for( i=0; i < race_changes[r].len; i+=1 ) {
        if( StringLength(message) > 2 ) {
            message += ", ";
        }

        entry = race_changes[r].changes[i].entry;
        message += apply_change_entry(player, race_changes[r].changes[i].cat, entry, race_changes[r].changes[i].field, race_changes[r].changes[i].oldval, race_changes[r].changes[i].newval);

        for( k=0; k<num_linked_units; k+=2 ) {
            if( entry == linked_units[k] ) {
                apply_linkage(player, race_changes[r].changes[i].cat, entry, linked_units[k+1], race_changes[r].changes[i].field, race_changes[r].changes[i].oldval, race_changes[r].changes[i].newval);
            }
        }

        if( StringLength(message) > 200 ) {
            info( message );
            message = "- ";
        }
    }

    if( StringLength(message) > 0 ) {
        info(message);
    }
    info(" ");
}


bool rando_field_fixed(int cat, string entry, string field, string friendly_name, int changes_id)
{
    fixed getval;
    fixed setval;
    fixed value;

    if( find_change(changes_id, entry, field) != -1 ) {
        return false;
    }

    getval = libNtve_gf_CatalogFieldValueGetAsReal(cat, entry, field, default_player);
    if( getval == 0 ) {
        debug(entry+" "+field+" failed to read");
        return false;
    }
    value = randomize(getval);
    if( value == getval ) {
        return false;
    }
    if( ! set_field_fixed(cat, entry, field, value ) ) {
        debug(entry+" "+field+" was "+FixedToString(getval,precision)+", failed to change to "+FixedToString(value,precision));
        return false;
    }
    setval = libNtve_gf_CatalogFieldValueGetAsReal(cat, entry, field, default_player);
    // TODO: determine if the re-read is needed
    if( getval == setval ) { return false; }

    if( ! set_field_fixed(cat, entry, field, getval ) ) {
        err(entry+" "+field+" was "+FixedToString(value,precision)+", failed to change back to "+FixedToString(getval,precision));
        return false;
    }

    add_change(changes_id, cat, entry, field, friendly_name, getval, setval);// TODO: maybe need to save the type or precision
    set_field_fixed(cat, entry, field, getval );

    return true;
}


bool rando_field_int(int cat, string entry, string field, string friendly_name, int changes_id)
{
    int getval;
    int setval;
    int value;

    if( find_change(changes_id, entry, field) != -1 ) {
        return false;
    }

    getval = CatalogFieldValueGetAsInt(cat, entry, field, default_player);
    if( getval == 0 ) {
        debug(entry+" "+field+" failed to read");
        return false;
    }
    value = FixedToInt( randomize(getval) );
    if( value == getval ) {
        return false;
    }
    if( ! set_field_string(cat, entry, field, IntToString(value) ) ) {
        debug(entry+" "+field+" was "+IntToString(getval)+", failed to change to "+IntToString(value));
        return false;
    }
    setval = CatalogFieldValueGetAsInt(cat, entry, field, default_player);
    // TODO: determine if the re-read is needed
    if( getval == setval ) { return false; }

    if( ! set_field_string(cat, entry, field, IntToString(getval) ) ) {
        err(entry+" "+field+" was "+IntToString(value)+", failed to change back to "+IntToString(getval));
        return false;
    }

    add_change(changes_id, cat, entry, field, friendly_name, getval, setval);
    set_field_string(cat, entry, field, IntToString(getval) );

    return true;
}
// #endregion

// #region Randomization Logic
int GetRandomField(int cat, string scope, string entry)
{
    int num;
    int i;

    if( scope == "CUnit" ) {
        for( i=0; i<num_randomized_buildings; i+=1 ) {
            if( entry == randomized_buildings[i] ) {
                scope = "CUnitBuilding";
                break;
            }
        }
    }

    num = 0;
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].scope == scope && randomized_fields[i].name != "" ) {
            num+=1;
        }
    }

    if( num == 0 ) {
        return -1;
    }

    num = RandomInt(0, num-1);
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].scope == scope && randomized_fields[i].name != "" ) {
            if( num == 0 ) {
                return i;
            }
            num-=1;
        }
    }

    return -1;
}


void modify_resources(string name, fixed percent) {
    int i;
    int num;
    int val;
    unitgroup units;
    unit u;
    int max;
    string behavior;

    behavior = CatalogFieldValueGet(c_gameCatalogUnit, name, "BehaviorArray[0].Link", default_player);
    max = CatalogFieldValueGetAsInt(c_gameCatalogBehavior, behavior, "Capacity", default_player);

    units = UnitGroup(name, 0, RegionEntireMap(), UnitFilter(0,0,0,0), 99999 );
    num = UnitGroupCount(units, c_unitCountAll);
    debug("found "+IntToString(num)+" of "+name);
    for( i=1; i<=num; i+=1 ) {
        u = UnitGroupUnit(units, i);
        val = UnitGetPropertyInt(u, c_unitPropResources, true);
        val = FixedToInt(IntToFixed(val) / 100 * percent);
        val = MinI(val, max);
        info(name+" behavior "+behavior+" set from "+IntToString(UnitGetPropertyInt(u, c_unitPropResources, true))+" to "+IntToString(val)+", max of "+IntToString(max));
        UnitSetPropertyInt(u, c_unitPropResources, val);
    }
}


void modify_behavior_resource(string name, fixed amount_percent, fixed amount, fixed time) {
    fixed val;

    // TODO:
    // Catalog field 'HarvestAmount' could not be written (Core: access denied to required object or service)
    // Catalog field 'HarvestTime' could not be written (Core: access denied to required object or service)
    // Catalog field 'Capacity' could not be written (Core: access denied to required object or service)
    // Catalog field 'Contents' could not be written (Core: access denied to required object or service)

    //val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "HarvestAmount", default_player);
    //val = val * amount / 100.0;
    //set_field_fixed(c_gameCatalogBehavior, name, "HarvestAmount", val );

    //val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "HarvestTime", default_player);
    //val = val * time / 100.0;
    //set_field_fixed(c_gameCatalogBehavior, name, "HarvestTime", val );

    //val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "Capacity", default_player);
    //val = val * amount_percent / 100.0;
    //set_field_string(c_gameCatalogBehavior, name, "Capacity", FixedToString(val,0) );

    //val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "Contents", default_player);
    //val = val * amount_percent / 100.0;
    //set_field_string(c_gameCatalogBehavior, name, "Contents", FixedToString(val,0) );
}


void randomize_economy() {
    fixed amount_percent;
    fixed harvestamount_percent;
    fixed harvesttime_percent;

    GameSetSeed( 0451 + seed );

    // CBehaviorResource minerals
    amount_percent = randomize_min_max(100, min_resources, max_resources);
    harvestamount_percent = randomize_min_max(100, min_resources, max_resources);
    harvesttime_percent = randomize_min_max(100, min_resources, max_resources);
    modify_behavior_resource("HighYieldMineralFieldMinerals", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HighYieldMineralFieldMinerals750", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMinerals", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMinerals450", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMinerals750", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMineralsNoRemove", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMineralsOpaque", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMineralsOpaque900", amount_percent, harvestamount_percent, harvesttime_percent);
    // TODO: fix these
    //add_change(no_race, 0, "Minerals Harvest", "Amount", "", 5, 5.0*harvestamount_percent/100);
    //add_change(no_race, 0, "Minerals Harvest", "Time", "", 2.786, 2.786*harvesttime_percent/100);

    // minerals
    modify_resources("MineralField", amount_percent);
    modify_resources("MineralField450", amount_percent);
    modify_resources("MineralField750", amount_percent);
    modify_resources("LabMineralField", amount_percent);
    modify_resources("LabMineralField750", amount_percent);
    modify_resources("BattleStationMineralField", amount_percent);
    modify_resources("BattleStationMineralField750", amount_percent);
    modify_resources("MineralFieldDefault", amount_percent);
    modify_resources("MineralFieldOpaque", amount_percent);
    modify_resources("MineralFieldOpaque900", amount_percent);
    modify_resources("PurifierMineralField", amount_percent);
    modify_resources("PurifierMineralField750", amount_percent);
    modify_resources("PurifierRichMineralField", amount_percent);
    modify_resources("PurifierRichMineralField750", amount_percent);
    modify_resources("RichMineralField", amount_percent);
    modify_resources("RichMineralField750", amount_percent);
    modify_resources("RichMineralFieldDefault", amount_percent);
    add_change(no_race, 0, "Minerals", "%", "", 100, amount_percent);

    // CBehaviorResource gas
    amount_percent = randomize_min_max(100, min_resources, max_resources);
    harvestamount_percent = randomize_min_max(100, min_resources, max_resources);
    harvesttime_percent = randomize_min_max(100, min_resources, max_resources);
    modify_behavior_resource("HarvestableRichVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableRichVespeneGeyserGasProtoss", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableRichVespeneGeyserGasZerg", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableTerrazineGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableTerrazineGeyserGasProtoss", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableTerrazineGeyserGasZerg", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableVespeneGeyserGasProtoss", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableVespeneGeyserGasZerg", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("RawRichVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("RawTerrazineGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("RawVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    // TODO: fix these
    //add_change(no_race, 0, "Gas Harvest", "Amount", "", 4, 4.0*harvestamount_percent/100);
    //add_change(no_race, 0, "Gas Harvest", "Time", "", 1.981, 1.981*harvesttime_percent/100);

    // gasses
    modify_resources("ProtossVespeneGeyser", amount_percent);
    modify_resources("PurifierVespeneGeyser", amount_percent);
    modify_resources("RichVespeneGeyser", amount_percent);
    modify_resources("ShakurasVespeneGeyser", amount_percent);
    modify_resources("SpacePlatformGeyser", amount_percent);
    modify_resources("VespeneGeyser", amount_percent);
    add_change(no_race, 0, "Gas", "%", "", 100, amount_percent);

    // TODO: for some reason it's able to read the starting workers, but trying to write them says
    // Catalog field 'StartingUnitArray[1].Count' could not be written (Core: access denied to required object or service)
    //for( i=0; i<16; i+=1 ) {
    //    info("Terr "+CatalogFieldValueGet(c_gameCatalogRace, "Terr", "StartingUnitArray[1].Count", i ));
    //    CatalogFieldValueSet(c_gameCatalogRace, "Terr", "StartingUnitArray[1].Count", i, IntToString(i) );
    //    info("Prot "+CatalogFieldValueGet(c_gameCatalogRace, "Prot", "StartingUnitArray[1].Count", i ));
    //    CatalogFieldValueSet(c_gameCatalogRace, "Prot", "StartingUnitArray[1].Count", i, IntToString(i) );
    //    info("Zerg "+CatalogFieldValueGet(c_gameCatalogRace, "Zerg", "StartingUnitArray[1].Count", i ));
    //    CatalogFieldValueSet(c_gameCatalogRace, "Zerg", "StartingUnitArray[1].Count", i, IntToString(i) );
    //}

    // TODO: randomize max supply, starting workers, maybe worker supply
}


int randomize_field(int cat, string scope, string entry, string field, string friendly_name, string val, int type, string field_type, int race_id, int num_fields );
int randomize_behavior(string entry, int race_id, int num_fields);
int randomize_effect(string entry, int race_id, int num_fields);
int randomize_weapon(string entry, int race_id, int num_fields);
int randomize_upgrade(string entry, int race_id, int num_fields);
int randomize_ability(string entry, int race_id, int num_fields);
int randomize_unit(string entry, int race_id, int num_fields);


int randomize_fields(int cat, string scope, string entry, string prefix, int race_id, int num_fields) {
    int i;
    int k;
    int slot;
    int slot2;
    int num;
    bool[1024] mask;
    int len;
    string field;
    string val;
    int type;
    string field_type;
    string friendly_name;

    debug("randomize_fields("+IntToString(cat)+", "+scope+", "+entry+", "+prefix+")");

    num = 0;
    for( i=0; num<num_fields && i<32; i+=1 ) {
        slot = GetRandomField(cat, scope, entry);
        if( slot == -1 ) {
            if( num==0 ) {
                debug(scope+" "+entry+" GetRandomField failed");
                note_add(scope+" GetRandomField failed");
            }
            return num;
        }
        if( mask[slot] ) { continue; }
        mask[slot] = true;

        field = randomized_fields[slot].name;
        type = randomized_fields[slot].type;
        
        if( randomized_fields[slot].is_array ) {
            len = CatalogFieldValueCount(cat, entry, prefix+field, default_player);
            field_type = CatalogFieldType(scope, prefix+field);
            for( k=0; num<num_fields && k<len; k+=1 ) {
                slot2 = RandomInt(0,len-1);
                friendly_name = randomized_fields[slot].friendly_name;
                if( type != type_struct ) {
                    val = CatalogFieldValueGet(cat, entry, prefix+field+"["+IntToString(slot2)+"]", default_player);
                    if( val == "" ) {
                        debug(scope+" "+entry+" failed CatalogFieldValueGet "+prefix+field+"["+IntToString(slot2)+"]");
                        continue;
                    }
                } else {
                    val = "";
                }
                num += randomize_field(cat, scope, entry, prefix+field+"["+IntToString(slot2)+"]", friendly_name, val, type, field_type, race_id, num_fields );
            }
        } else {
            friendly_name = randomized_fields[slot].friendly_name;
            if( type != type_struct ) {
                val = CatalogFieldValueGet(cat, entry, prefix+field, default_player);
                if( val == "" ) {
                    debug(scope+" "+entry+" failed CatalogFieldValueGet "+prefix+field);
                    continue;
                }
            } else {
                val = "";
            }
            if( friendly_name != "" && StringFind(friendly_name, ".", true) == 1 ) {
                friendly_name = CatalogFieldValueGet(cat, entry, prefix+friendly_name, default_player);
                if( friendly_name == "" ) {
                    debug(scope+" "+entry+" failed CatalogFieldValueGet friendly_name "+prefix+friendly_name);
                    continue;
                }
            }
            num += randomize_field(cat, scope, entry, prefix+field, friendly_name, val, type, "", race_id, num_fields );
        }
    }

    return num;
}


int randomize_behavior(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogBehavior;
    string scope;
    if( entry == "" ) {
        note_add("randomize_behavior empty entry");
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
}


int randomize_effect(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogEffect;
    string scope;
    if( entry == "" ) {
        note_add("randomize_effect empty entry");
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
}


int randomize_weapon(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogWeapon;
    string scope;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
}


int randomize_upgrade(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogUpgrade;
    string scope;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    // TODO: maybe if EffectArray[i].Operation is anything except Set, then it can be randomized
    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
}


int randomize_ability(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogAbil;
    string scope;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
}


int randomize_unit(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogUnit;
    string scope = "CUnit";
    int i;
    int len;
    int slot;
    string val;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
}


string get_random_unit() {
    int slot;
    slot = RandomInt(0, num_randomized_units-1);
    return randomized_units[slot];
}


void randomize_units(int faction, int changes_per_faction) {
    int cat = c_gameCatalogUnit;
    string scope = "CUnit";
    string entry;
    string cost_category;
    int race_id;
    int i;
    int slot;

    // TODO: can we do 1 per frame or per tick?
    // TODO: how to handle buildings with separate randomized fields?

    for( i=1; i<=changes_per_faction*20; i+=1 ) {

        if( race_changes[faction*4 + terran].len >= changes_per_faction
            && race_changes[faction*4 + protoss].len >= changes_per_faction
            && race_changes[faction*4 + zerg].len >= changes_per_faction
        ) {
            break;
        }
        GameSetSeed( 5 + seed*3 + i*2713 + faction*3331);
        entry = get_random_unit();
        race_id = get_race_id(cat, scope, entry);
        if( race_id == no_race ) {
            continue;
        }
        race_id += faction*4;
        if( race_changes[race_id].len >= changes_per_faction ) {
            continue;
        }

        randomize_unit(entry, race_id, RandomInt(1,changes_per_unit) );
    }

    GameSetSeed(seed);
}


int randomize_field(int cat, string scope, string entry, string field, string friendly_name, string val, int type, string field_type, int race_id, int num_fields ) {
    if( type == type_fixed ) {
        if( rando_field_fixed(cat, entry, field, friendly_name, race_id) ) {
            return 1;
        }
    }
    else if( type == type_int ) {
        if( rando_field_int(cat, entry, field, friendly_name, race_id) ) {
            return 1;
        }
    }
    else if( type == type_unit ) {
        return randomize_unit(val, race_id, num_fields);
    }
    else if( type == type_ability ) {
        return randomize_ability(val, race_id, num_fields);
    }
    else if( type == type_effect ) {
        return randomize_effect(val, race_id, num_fields);
    }
    else if( type == type_weapon ) {
        return randomize_weapon(val, race_id, num_fields);
    }
    else if( type == type_upgrade ) {
        return randomize_upgrade(val, race_id, num_fields);
    }
    else if( type == type_behavior ) {
        return randomize_behavior(val, race_id, num_fields);
    }
    else if( type == type_struct ) {
        if( field_type == "" ) {
            field_type = CatalogFieldType(scope, field);
        }
        return randomize_fields(cat, field_type, entry, field, race_id, num_fields);
    }
    else {
        if( field_type == "" ) {
            field_type = CatalogFieldType(CatalogEntryScope(cat, entry), field);
        }
        info(scope+" "+entry+" has "+field_type+" ("+IntToString(type)+") "+field+" "+friendly_name+", value: "+val );
        note_add(scope+" has "+field_type+" ("+IntToString(type)+") "+field+", value: "+val );
        return 0;
    }

    return 0;
}


void do_rando() {
    int i;
    bool seed_was_locked;

    notice("Randomizing with seed "+IntToString(seed)+", "+IntToString(num_factions)+" factions, "+IntToString(num_bans)+" bans, "+IntToString(changes_per_faction)+" changes per faction, "+FixedToString(min_percent,1)+"% minimum, "+FixedToString(max_percent,1)+"% maximum.");
    Wait(0.1, c_timeReal);

    seed_was_locked = GameIsSeedLocked();
    GameSetSeed(seed);

    randomize_economy();
    for( i=0; i < num_factions; i+=1 ) {
        Wait(0.1, c_timeReal);
        race_changes[i*4 + no_race].name = "General";
        race_changes[i*4 + terran].name = "Terran Faction "+IntToString(i+1);
        race_changes[i*4 + protoss].name = "Protoss Faction "+IntToString(i+1);
        race_changes[i*4 + zerg].name = "Zerg Faction "+IntToString(i+1);
        randomize_units(i, changes_per_faction);
    }

    notes_log();
    GameSetSeedLocked(seed_was_locked);
}
// #endregion

// #region GUI
int create_continue_button(int dialog, string button_text, string callback) {
    submit_button = DialogControlCreate(dialog, c_triggerControlTypeButton);
    libNtve_gf_SetDialogItemText(submit_button, StringToText(button_text), PlayerGroupAll() );
    DialogControlSetSize(submit_button, PlayerGroupAll(), 400, 60);
    DialogControlSetPosition(submit_button, PlayerGroupAll(), c_anchorBottom, 0, 40);
    libNtve_gf_SetDialogItemTooltip(submit_button, StringToText(button_text), PlayerGroupAll());
    TriggerAddEventDialogControl(TriggerCreate(callback), c_playerAny, submit_button, c_triggerControlEventTypeClick);

    return submit_button;
}


int create_changes_list(int dialog) {
    int list;
    list = DialogControlCreate(dialog, c_triggerControlTypeListBox);
    DialogControlSetSize(list, PlayerGroupAll(), 1200, 800);
    DialogControlSetPosition(list, PlayerGroupAll(), c_anchorCenter, 0, 0);

    return list;
}


int create_ban_pick_button(int dialog, int list, string button_text, string callback) {
    int button;

    button = DialogControlCreate(dialog, c_triggerControlTypeButton);
    libNtve_gf_SetDialogItemText(button, StringToText(button_text), PlayerGroupAll() );
    DialogControlSetSize(button, PlayerGroupAll(), 200, 100);
    DialogControlSetPositionRelative( button, PlayerGroupAll(), c_anchorRight, list, c_anchorLeft, -50, 0 );
    libNtve_gf_SetDialogItemTooltip(button, StringToText(button_text), PlayerGroupAll());
    TriggerAddEventDialogControl(TriggerCreate(callback), c_playerAny, button, c_triggerControlEventTypeClick);

    return button;
}


int create_factions_dropdown(int dialog, int list, string callback) {
    int faction;
    int race;
    int dropdown;
    string name;

    // hide races that aren't in the game

    dropdown = DialogControlCreate(dialog, c_triggerControlTypePulldown);
    DialogControlSetSize( dropdown, PlayerGroupAll(), 500, 50 );
    DialogControlSetPositionRelative( dropdown, PlayerGroupAll(), c_anchorBottom, list, c_anchorTop, 0, 0 );

    DialogControlAddItem(dropdown, PlayerGroupAll(), StringToText("General Changes") );
    for( race=1; race<4; race+=1 ) {
        for( faction=0; faction<num_factions; faction+=1 ) {
            name = race_changes[faction*4 + race].name;
            DialogControlAddItem(dropdown, PlayerGroupAll(), StringToText(name) );
        }
    }

    TriggerAddEventDialogControl( TriggerCreate(callback), c_playerAny, dropdown, c_triggerControlEventTypeSelectionChanged );

    return dropdown;
}


void show_changes(int list, playergroup players, int race) {
    int i;
    string s;

    DialogControlRemoveAllItems(list, players);

    // TODO: zerg buildings count the cost of the drone...

    for( i=0; i<race_changes[race].len; i+=1 ) {
        s = race_changes[race].changes[i].entry;
        if( race_changes[race].changes[i].friendly_name != "" ) {
            s += " " + race_changes[race].changes[i].friendly_name;
        }
        s += " " + race_changes[race].changes[i].field;
        s += " changed from ";

        if( IntToFixed(FixedToInt(race_changes[race].changes[i].oldval)) == race_changes[race].changes[i].oldval
            && IntToFixed(FixedToInt(race_changes[race].changes[i].newval)) == race_changes[race].changes[i].newval ) {
            s += FixedToString(race_changes[race].changes[i].oldval,0)
                + " to "+FixedToString(race_changes[race].changes[i].newval,0);
        }
        else {
            s += FixedToString(race_changes[race].changes[i].oldval,precision)
                + " to "+FixedToString(race_changes[race].changes[i].newval,precision);
        }

        DialogControlAddItem(list, players, StringToText(s) );
    }
}


int get_player_faction_ban_slot(int player, int faction) {
    return faction + player*max_factions*4;
}


int get_player_num_bans(int player) {
    int faction;
    int num;
    for( faction=0; faction<max_factions*4; faction+=1 ) {
        if( players_bans[ get_player_faction_ban_slot(player, faction) ] ) {
            num+=1;
        }
    }
    return num;
}


bool faction_banned_for_player(int player, int faction) {
    int len;
    int i;
    int p;
    playergroup players;

    players = PlayerGroupAlliance(c_playerGroupEnemy, player);
    len = PlayerGroupCount(players);
    for( i=1; i<=len; i+=1 ) {
        p = PlayerGroupPlayer(players, i);

        if( players_bans[get_player_faction_ban_slot(p, faction)] ) {
            debug(race_changes[faction].name+" is banned for "+SPlayerName(player));
            return true;
        }
    }
    return false;
}


int get_race_from_selected(int selected) {
    return selected % 4;
}


int get_selected_faction(int player, int dropdown) {
    int selected;
    int faction;
    int race;

    selected = DialogControlGetSelectedItem( dropdown, player );
    if( selected == 1 ) {
        selected = 0;// general changes
    }
    else {
        selected -= 2;
        faction = selected % num_factions;
        race = selected / num_factions + 1;
        selected = faction*4 + race;
    }
    info("dropdown_factions, faction: "+IntToString(faction)+", race: "+IntToString(race));
    return selected;
}


bool ban_button_click(bool testConds, bool runActions) {
    // TODO: show counter for remaining bans
    int selected;
    int player;

    player = EventPlayer();
    selected = get_selected_faction(player, factions_dropdown);

    if( players_bans[get_player_faction_ban_slot(player, selected)] ) {
        players_bans[get_player_faction_ban_slot(player, selected)] = false;
        info( SPlayerName(player) + " clicked unban for " + race_changes[selected].name );
        libNtve_gf_SetDialogItemText(ban_button, StringToText("Ban"), PlayerGroupSingle(player) );
        libNtve_gf_SetDialogItemTooltip(ban_button, StringToText("Ban"), PlayerGroupSingle(player) );
    } else {
        players_bans[get_player_faction_ban_slot(player, selected)] = true;
        info( SPlayerName(player) + " clicked ban for " + race_changes[selected].name );
        libNtve_gf_SetDialogItemText(ban_button, StringToText("Unban"), PlayerGroupSingle(player) );
        libNtve_gf_SetDialogItemTooltip(ban_button, StringToText("Unban"), PlayerGroupSingle(player) );
    }

    return true;
}


bool pick_button_click(bool testConds, bool runActions) {
    int selected;
    int player;

    player = EventPlayer();
    selected = get_selected_faction(player, factions_dropdown);

    players_picks[player] = selected;
    info( SPlayerName(player) + " clicked pick for " + race_changes[selected].name );
    DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), false);

    return true;
}


void pick_faction_dropdown(int player, int selected, int race) {
    if( faction_banned_for_player(player, selected) ) {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), false);
        return;
    }

    if( players_picks[player] == selected ) {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), false);
        return;
    }

    if( race == terran && PlayerRace(player) == "Terr" ) {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), true);
    } else if( race == protoss && PlayerRace(player) == "Prot" ) {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), true);
    } else if( race == zerg && PlayerRace(player) == "Zerg" ) {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), true);
    }
    else {
        DialogControlSetEnabled(pick_button, PlayerGroupSingle(player), false);
    }
}


void ban_faction_dropdown(int player, int selected, int race) {
    if( race == no_race ) {
        DialogControlSetEnabled(ban_button, PlayerGroupSingle(player), false);
        return;
    }

    if( players_bans[get_player_faction_ban_slot(player, selected)] ) {
        libNtve_gf_SetDialogItemText(ban_button, StringToText("Unban"), PlayerGroupSingle(player) );
        libNtve_gf_SetDialogItemTooltip(ban_button, StringToText("Unban"), PlayerGroupSingle(player) );
        DialogControlSetEnabled(ban_button, PlayerGroupSingle(player), true);
        return;
    }
    else {
        libNtve_gf_SetDialogItemText(ban_button, StringToText("Ban"), PlayerGroupSingle(player) );
        libNtve_gf_SetDialogItemTooltip(ban_button, StringToText("Ban"), PlayerGroupSingle(player) );
    }

    if( get_player_num_bans(player) >= num_bans ) {
        DialogControlSetEnabled(ban_button, PlayerGroupSingle(player), false);
    } else {
        DialogControlSetEnabled(ban_button, PlayerGroupSingle(player), true);
    }
}


bool dropdown_factions(bool testConds, bool runActions) {
    int selected;
    int race;
    int dropdown;
    int dialog;
    int player;

    dropdown = EventDialogControl();
    dialog = DialogControlGetDialog(dropdown);
    player = EventPlayer();
    selected = get_selected_faction(player, dropdown);
    race = get_race_from_selected(selected);
    show_changes(changes_list, PlayerGroupSingle(EventPlayer()), selected );

    if( dialog == dialog_pick_faction ) {
        pick_faction_dropdown(player, selected, race);
    }
    else if( dialog == dialog_bans ) {
        ban_faction_dropdown(player, selected, race);
    }
    return true;
}


void clear_waiting() {
    int i;
    for( i=0; i<16; i+=1 ) {
        players_waiting[i] = false;
    }
}


bool is_waiting(int player, int button) {
    int i;
    int num_players_waiting;
    playergroup players;

    players_waiting[player] = true;

    players = GetPlayersOfType(c_playerTypeUser);

    DialogControlSetEnabled(button, PlayerGroupSingle(player), false);
    libNtve_gf_SetDialogItemText(button, StringToText("Waiting For Other Players"), PlayerGroupSingle(player) );
    libNtve_gf_SetDialogItemTooltip(button, StringToText("Waiting For Other Players"), PlayerGroupSingle(player) );

    for( i=0; i<16; i+=1 ) {
        if( PlayerGroupHasPlayer(players, i) && players_waiting[i] ) {
            num_players_waiting += 1;
        }
    }

    if( num_players_waiting < PlayerGroupCount(players) ) {
        debug("is_waiting("+SPlayerName(player)+") "+IntToString(num_players_waiting)+" players waiting out of "+IntToString(PlayerGroupCount(players)) );
        return true;
    }

    debug("is_waiting("+SPlayerName(player)+") done waiting, "+IntToString(num_players_waiting)+" players waiting out of "+IntToString(PlayerGroupCount(players)) );

    clear_waiting();

    return false;
}


void apply_changes_player(int player) {
    int faction;

    info("apply_changes_player " + SPlayerName(player) );
    faction = players_picks[player];
    // TODO: ensure null picks don't pick a banned faction, give them a random faction for more fun AI FFAs
    // TODO: ensure picked correct race

    if( faction == 0 ) {
        if( PlayerRace(player) == "Terr" ) {
            faction = faction*4 + terran;
        } else if( PlayerRace(player) == "Prot" ) {
            faction = faction*4 + protoss;
        } else if( PlayerRace(player) == "Zerg" ) {
            faction = faction*4 + zerg;
        } else {
            err("unknown PlayerRace("+IntToString(player)+" == "+PlayerRace(player));
        }

        notice( SPlayerName(player) + " was assigned " + race_changes[faction].name );
    }
    else {
        notice( SPlayerName(player) + " chose " + race_changes[faction].name );
    }
    apply_changes(faction, player);
    info("apply_changes_player done for " + SPlayerName(player) );
}


bool start_game(bool testConds, bool runActions) {
    int i;

    info("start_game");
    TriggerDestroy(dialog_timeout);
    DialogSetVisible(dialog_pick_faction, PlayerGroupAll(), false);
    DialogDestroy(dialog_pick_faction);

    libNtve_gf_HideGameUI( true, PlayerGroupAll() );
    for( i=0; i<16; i+=1 ) {// TODO: active players only?
        CameraLockInput(i, false);
        MeleeSetOption(i, c_meleeOptionStalemate, true);
    }
    GameSetGlobalTimeScale(1);
    return true;
}


void start_review() {
    int i;
    int len;
    playergroup players;

    players = PlayerGroupActive();
    len = PlayerGroupCount(players);
    info("start_review, with "+IntToString(len)+" active players");
    for( i=1; i<=len; i+=1 ) {
        apply_changes_player( PlayerGroupPlayer(players, i) );
    }

    DialogControlSetVisible(pick_button, players, false);
    DialogControlDestroy(submit_button);
    create_continue_button(dialog_pick_faction, "Start Game", "start_game");
    
    TriggerDestroy(dialog_timeout);
    dialog_timeout = TriggerCreate("start_game");
    TriggerAddEventTimeElapsed( dialog_timeout, 30, c_timeReal );
}


bool review_timeout(bool testConds, bool runActions) {
    info("review_timeout");
    clear_waiting();
    start_review();
    return true;
}


bool review_button_pressed(bool testConds, bool runActions) {
    int i;
    int faction;
    int player;
    int dialog;
    int button;

    player = EventPlayer();
    info("review_button_pressed "+SPlayerName(player));
    button = EventDialogControl();
    dialog = DialogControlGetDialog(button);

    DialogControlSetVisible(pick_button, PlayerGroupSingle(player), false);

    if( is_waiting(player, button) ) {
        return true;
    }

    start_review();
    return true;
}


int create_dialog_pick_faction() {
    playergroup players;
    int button;

    info("create_dialog_pick_faction");
    players = PlayerGroupAll();

    dialog_pick_faction = DialogCreate(500, 500, c_anchorCenter, 0, 0, true);
    DialogSetTitle(dialog_pick_faction, StringToText(dialog_title) );
    DialogSetFullscreen(dialog_pick_faction, true);

    create_continue_button(dialog_pick_faction, "Continue To Review", "review_button_pressed");
    
    TriggerDestroy(dialog_timeout);
    dialog_timeout = TriggerCreate("review_timeout");
    TriggerAddEventTimeElapsed( dialog_timeout, 60, c_timeReal );

    changes_list = create_changes_list(dialog_pick_faction);

    factions_dropdown = create_factions_dropdown(dialog_pick_faction, changes_list, "dropdown_factions");

    pick_button = create_ban_pick_button(dialog_pick_faction, changes_list, "Pick", "pick_button_click");
    DialogControlSetEnabled(pick_button, players, false);

    DialogControlAddItem(changes_list, players, StringToText("Select a race/faction to see the changes") );
    
    if( num_factions > 1 ) {
        DialogControlAddItem(changes_list, players, StringToText("Click on the Pick button to select that faction to play as") );
    } else {
        start_review();
    }

    DialogSetVisible(dialog_pick_faction, players, true);

    return dialog_pick_faction;
}


void start_pick_factions() {
    int player;
    int faction;
    int i;
    int len;
    playergroup players;

    info("start_pick_factions");
    players = PlayerGroupActive();
    len = PlayerGroupCount(players);
    for( i=1; i<=len; i+=1 ) {
        player = PlayerGroupPlayer(players, i);
        for( faction=0; faction < 4*max_factions; faction+=1 ) {
            if( players_bans[get_player_faction_ban_slot(player, faction)] ) {
                notice( SPlayerName(player) + " banned " + race_changes[faction].name );
            }
        }
    }

    clear_waiting();
    DialogSetVisible(dialog_bans, PlayerGroupAll(), false);
    DialogDestroy(dialog_bans);

    create_dialog_pick_faction();
}


bool ban_factions_timeout(bool testConds, bool runActions) {
    info("ban_factions_timeout");
    start_pick_factions();
    return true;
}


bool bans_done_button_pressed(bool testConds, bool runActions) {
    int i;
    int player;
    int num_players_waiting;
    playergroup players;
    int button;

    player = EventPlayer();
    info("bans_done_button_pressed "+SPlayerName(player));

    DialogControlSetVisible(ban_button, PlayerGroupSingle(player), false);

    if( is_waiting(player, EventDialogControl()) ) {
        return true;
    }

    start_pick_factions();

    return true;
}


int create_dialog_bans() {
    int width;
    int height;
    //int race;
    playergroup players;
    int button;

    info("create_dialog_bans");
    players = PlayerGroupAll();

    // TODO: bans remaining 2 / 3
    // ban/unban button
    // timer
    // picks screen
    // create wait screens in advance for every player, show them 1 player at a time

    dialog_bans = DialogCreate(500, 500, c_anchorCenter, 0, 0, true);
    DialogSetTitle(dialog_bans, StringToText(dialog_title) );
    DialogSetFullscreen(dialog_bans, true);

    // TODO: how to get screen size? these seem to return 500, 500 even though I set the dialog to fullscreen
    width = DialogGetWidth(dialog_bans);
    height = DialogGetHeight(dialog_bans);

    changes_list = create_changes_list(dialog_bans);

    factions_dropdown = create_factions_dropdown(dialog_bans, changes_list, "dropdown_factions");

    ban_button = create_ban_pick_button(dialog_bans, changes_list, "Ban", "ban_button_click");
    DialogControlSetEnabled(ban_button, players, false);

    DialogControlAddItem(changes_list, players, StringToText("Select a race/faction to see the changes") );
    DialogControlAddItem(changes_list, players, StringToText("Click on the Ban button to disallow your opponents from picking that faction") );

    create_continue_button(dialog_bans, "Continue", "bans_done_button_pressed");

    TriggerDestroy(dialog_timeout);
    dialog_timeout = TriggerCreate("ban_factions_timeout");
    TriggerAddEventTimeElapsed( dialog_timeout, 120, c_timeReal );

    DialogSetVisible(dialog_bans, players, true);

    return dialog_bans;
}


bool start_rando_button_pressed(bool testConds, bool runActions) {
    string sseed;
    string snum_factions;
    string snum_bans;
    string schanges_per_faction;
    //string schanges_per_unit;
    string smin_percent;
    string smax_percent;
    int loading_screen;
    int loading_text;
    int num_players;
    int max_bans;

    info("start_rando_button_pressed");
    TriggerDestroy(dialog_timeout);

    sseed = libNtve_gf_DialogItemEditValue(seed_editbox, default_player);
    if( sseed != "" ) {
        seed = StringToInt(sseed);
    }

    num_players = PlayerGroupCount(PlayerGroupActive());
    snum_factions = libNtve_gf_DialogItemEditValue(num_factions_editbox, default_player);
    if( snum_factions != "" ) {
        num_factions = StringToInt(snum_factions);
        if( num_factions > max_factions ) {
            num_factions = max_factions;
        }
        if( num_factions < 1 ) {
            num_factions = 1;
        }
    }

    snum_bans = libNtve_gf_DialogItemEditValue(num_bans_editbox, default_player);
    if(num_players > 1 && num_factions > 1 ) {
        max_bans = num_factions / (num_players-1);
    } else {
        max_bans = num_factions - 1;
    }
    if( snum_bans != "" ) {
        num_bans = StringToInt(snum_bans);
        if( num_bans > max_bans ) {
            num_bans = max_bans;
        }
        if( num_bans < 0 ) {
            num_bans = 0;
        }
    }

    schanges_per_faction = libNtve_gf_DialogItemEditValue(changes_per_faction_editbox, default_player);
    if( schanges_per_faction != "" ) {
        changes_per_faction = StringToInt(schanges_per_faction);
        if( changes_per_faction > 200 ) {
            changes_per_faction = 200;
        }
        if( changes_per_faction < 1 ) {
            changes_per_faction = 1;
        }
    }

    smin_percent = libNtve_gf_DialogItemEditValue(min_percent_editbox, default_player);
    if( smin_percent != "" ) {
        min_percent = StringToFixed(smin_percent);
    }

    smax_percent = libNtve_gf_DialogItemEditValue(max_percent_editbox, default_player);
    if( smax_percent != "" ) {
        max_percent = StringToFixed(smax_percent);
    }

    DialogSetVisible(dialog_start, PlayerGroupAll(), false);
    DialogDestroy(dialog_start);

    DialogSetVisible(dialog_wait, PlayerGroupAll(), false);
    DialogDestroy(dialog_wait);

    loading_screen = DialogCreate(500, 500, c_anchorCenter, 0, 0, true);
    DialogSetTitle(loading_screen, StringToText(dialog_title) );
    DialogSetFullscreen(loading_screen, true);

    loading_text = DialogControlCreate(loading_screen, c_triggerControlTypeLabel);
    DialogControlSetSize(loading_text, PlayerGroupAll(), 300, 300);
    DialogControlSetPosition(loading_text, PlayerGroupAll(), c_anchorCenter, 0, 0);
    libNtve_gf_SetDialogItemText( loading_text, StringToText("Please wait while randomizing, this might take a few seconds..."), PlayerGroupAll() );
    libNtve_gf_SetDialogItemTooltip( loading_text, StringToText("Please wait while randomizing, this might take a few seconds..."), PlayerGroupAll() );

    DialogSetVisible(loading_screen, PlayerGroupAll(), true);

    do_rando();

    DialogSetVisible(loading_screen, PlayerGroupAll(), false);
    DialogDestroy(loading_screen);

    if( num_bans > 0 ) {
        create_dialog_bans();
    } else {
        start_pick_factions();
    }
    return true;
}


int create_edit_box_with_label(int dialog, playergroup players, string defaulttext, string labeltext, string tooltip, int row) {
    int label;
    int editbox;
    int y;
    int row_height;

    row_height = 80;
    y = row*row_height - 3*row_height;

    editbox = DialogControlCreate(dialog, c_triggerControlTypeEditBox);
    DialogControlSetSize(editbox, players, 300, 50);
    DialogControlSetPosition(editbox, players, c_anchorCenter, 150, y);
    libNtve_gf_SetDialogItemTooltip(editbox, StringToText(tooltip), players);
    libNtve_gf_SetDialogItemEditorValue(editbox, defaulttext, players);

    label = DialogControlCreate(dialog, c_triggerControlTypeLabel);
    DialogControlSetSize(label, players, 300, 50);
    libNtve_gf_SetDialogItemText(label, StringToText(labeltext), players );
    libNtve_gf_SetDialogItemTooltip(label, StringToText(tooltip), players);

    DialogControlSetPositionRelative(label, players, c_anchorRight, editbox, c_anchorLeft, 0, 15);
    return editbox;
}


int create_dialog_settings() {
    playergroup players;
    int num_players;

    info("create_dialog_settings");
    players = PlayerGroupSingle(default_player);

    num_players = PlayerGroupCount(PlayerGroupActive());
    // TODO: timeouts for dialogs with countdown
    if( num_players > 4 ) {
        num_bans = 0;
        num_factions = 3;
    }
    else {
        num_bans = 1;
        num_factions = MaxI(3, num_players+1);
    }

    dialog_start = DialogCreate(500, 500, c_anchorCenter, 0, 0, true);
    DialogSetTitle(dialog_start, StringToText(dialog_title) );
    DialogSetFullscreen(dialog_start, true);

    seed_editbox = create_edit_box_with_label(dialog_start, players, IntToString(seed), "Seed: ", "The seed used for randomization", 0);
    num_factions_editbox = create_edit_box_with_label(dialog_start, players, IntToString(num_factions), "Factions: ", "How many factions to generate for each race", 1);
    num_bans_editbox = create_edit_box_with_label(dialog_start, players, IntToString(num_bans), "Bans: ", "How many bans each player can use", 2);

    changes_per_faction_editbox = create_edit_box_with_label(dialog_start, players, IntToString(changes_per_faction), "Changes per faction: ", "How many things to change for each faction", 3);
    //changes_per_unit_editbox = create_edit_box_with_label(dialog_start, players, IntToString(changes_per_unit), "Changes per unit: ", "Maximum number of things to change for each unit", 4);

    min_percent_editbox = create_edit_box_with_label(dialog_start, players, FixedToString(min_percent,0), "Minimum Value %: ", "The lowest each stat can be changed to", 4);
    max_percent_editbox = create_edit_box_with_label(dialog_start, players, FixedToString(max_percent,0), "Maximum Value %: ", "The highest each stat can be changed to", 5);

    create_continue_button(dialog_start, "Continue", "start_rando_button_pressed");

    dialog_timeout = TriggerCreate("start_rando_button_pressed");
    TriggerAddEventTimeElapsed( dialog_timeout, 45, c_timeReal );

    DialogSetVisible(dialog_start, players, true);

    return dialog_start;
}


int create_dialog_wait_settings() {
    playergroup players;
    int label;
    
    info("create_dialog_wait_settings");
    players = PlayerGroupCopy(PlayerGroupAll());// not sure if it needs to be copied
    PlayerGroupRemove(players, default_player);

    dialog_wait = DialogCreate(500, 500, c_anchorCenter, 0, 0, true);
    DialogSetTitle(dialog_wait, StringToText(dialog_title) );
    DialogSetFullscreen(dialog_wait, true);

    label = DialogControlCreate(dialog_wait, c_triggerControlTypeLabel);
    DialogControlSetSize(label, players, 100, 50);
    DialogControlSetPosition(label, players, c_anchorCenter, 0, 0);
    libNtve_gf_SetDialogItemText(label, StringToText("Waiting for host to choose settings..."), players );
    libNtve_gf_SetDialogItemTooltip(label, StringToText("Waiting for host to choose settings..."), players);

    // TODO: some explanations

    DialogSetVisible(dialog_wait, players, true);
    return dialog_wait;
}


void create_dialog_start() {
    int i;

    info("create_dialog_start");
    for( i=0; i<16; i+=1 ) {// TODO: active players only?
        CameraLockInput(i, true);
        // TODO: fix disabling stalemate
        MeleeSetOption(i, c_meleeOptionStalemate, false);
    }

    GameSetGlobalTimeScale(0);
    libNtve_gf_HideGameUI( false, PlayerGroupAll() );

    create_dialog_settings();
    create_dialog_wait_settings();
}
// #endregion

// #region Tests
void run_tests() {
    int player;
    int faction;
    int i;

    info("run_tests");
    players_bans[get_player_faction_ban_slot(1, 5)] = true;
    for( player=0; player<16; player+=1 ) {
        for( faction=0; faction < 4*max_factions; faction+=1 ) {
            if( players_bans[get_player_faction_ban_slot(player, faction)] ) {
                debug( "Player " + IntToString(player) + " banned " + IntToString(faction) + " get_player_faction_ban_slot(player, faction) == " + IntToString(get_player_faction_ban_slot(player, faction)) );
            }
        }
    }
    players_bans[get_player_faction_ban_slot(1, 5)] = false;

    info("PlayerGroupActive() found "+IntToString(PlayerGroupCount(PlayerGroupActive()))+" players");
    info("PlayerGroupAll() found "+IntToString(PlayerGroupCount(PlayerGroupAll()))+" players");

    for( i=0; i<16; i+=1 ) {
        if( PlayerGroupHasPlayer(PlayerGroupAll(), i) ) {
            info("PlayerGroupAll() has player "+IntToString(i)+" with type "+IntToString(PlayerType(i)) );
        }
    }
}
// #endregion

// #region Configs Defaults
void AddRandomizedField(string scope, int type, string name)
{
    int i;
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].name == "" ) {
            randomized_fields[i].scope = scope;
            randomized_fields[i].type = type;
            randomized_fields[i].name = name;
            randomized_fields[i].is_array = false;
            return;
        }
    }
    err("AddRandomizedField full");
}

void AddRandomizedFieldFriendlyName(string scope, int type, string name, string friendly_name)
{
    int i;
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].name == "" ) {
            randomized_fields[i].scope = scope;
            randomized_fields[i].type = type;
            randomized_fields[i].name = name;
            randomized_fields[i].friendly_name = friendly_name;
            randomized_fields[i].is_array = false;
            return;
        }
    }
    err("AddRandomizedFieldFriendlyName full");
}

void AddRandomizedFieldArray(string scope, int type, string name)
{
    int i;
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].name == "" ) {
            randomized_fields[i].scope = scope;
            randomized_fields[i].type = type;
            randomized_fields[i].name = name;
            randomized_fields[i].is_array = true;
            return;
        }
    }
    err("AddRandomizedFieldArray full");
}

void CopyRandomizedFields(string from, string scope, string friendly_name)
{
    int i;
    for( i=0; i<256; i+=1 ) {
        if( randomized_fields[i].scope == from ) {
            if( randomized_fields[i].is_array ) {
                AddRandomizedFieldArray(scope, randomized_fields[i].type, randomized_fields[i].name);
            }
            else {
                AddRandomizedFieldFriendlyName(scope, randomized_fields[i].type, randomized_fields[i].name, friendly_name);
            }
        }
    }
}


void add_randomized_unit(string entry) {
    randomized_units[num_randomized_units] = entry;
    num_randomized_units += 1;
}


void add_randomized_building(string entry) {
    add_randomized_unit(entry);
    randomized_buildings[num_randomized_buildings] = entry;
    num_randomized_buildings += 1;
}


void link_unit(string a, string b) {
    linked_units[num_linked_units] = a;
    linked_units[num_linked_units+1] = b;
    num_linked_units += 2;
}


void add_randomized_unit_linked(string entry, string other) {
    add_randomized_unit(entry);
    link_unit(entry, other);
}


void add_randomized_building_linked(string entry, string other) {
    add_randomized_building(entry);
    link_unit(entry, other);
}


void add_randomized_unit_burrow(string entry) {
    add_randomized_unit_linked(entry, entry+"Burrowed");
}


void main () {
    int oldseed;
    int i;
    
    seed=1337;
    seed = RandomInt(1, 999999);
    min_percent = 35;
    max_percent = 200;
    min_resources = 60;
    max_resources = 150;
    num_factions = 3;
    num_bans = 0;
    changes_per_faction = 10;
    changes_per_unit = 2;

    TriggerDebugOutputEnable(true);
    TriggerDebugSetTypeFile(1, "SC2Rando.txt");
    run_tests();

    // Units
    // Protoss Units
    add_randomized_unit_linked("Adept", "AdeptPhaseShift");
    add_randomized_unit("Archon");
    add_randomized_unit("Carrier");
    add_randomized_unit("Colossus");
    add_randomized_unit("DarkTemplar");
    add_randomized_unit_linked("Disruptor", "DisruptorPhased");
    add_randomized_unit("HighTemplar");
    add_randomized_unit("Immortal");
    add_randomized_unit("Interceptor");
    add_randomized_unit("Mothership");
    add_randomized_unit_linked("Observer", "ObserverSiegeMode");
    add_randomized_unit("Oracle");
    add_randomized_unit("Phoenix");
    add_randomized_unit("PhotonCannon");
    add_randomized_unit("Sentry");
    add_randomized_unit("ShieldBattery");
    add_randomized_unit("Stalker");
    add_randomized_unit("Tempest");
    add_randomized_unit("VoidRay");
    add_randomized_unit_linked("WarpPrism", "WarpPrismPhasing");
    add_randomized_unit("Zealot");

    // Terran Units
    add_randomized_unit("AutoTurret");
    add_randomized_unit("Banshee");
    add_randomized_unit("Battlecruiser");
    add_randomized_unit("Bunker");
    add_randomized_unit("Cyclone");
    add_randomized_unit_linked("Ghost", "GhostAlternate");
    link_unit("Ghost", "GhostNova");
    add_randomized_unit_linked("Hellion", "HellionTank");// HellionTank is the Hellbat
    add_randomized_unit_linked("LiberatorAG", "Liberator");
    add_randomized_unit("Marauder");
    add_randomized_unit("Marine");
    add_randomized_unit("Medivac");
    add_randomized_unit("MissileTurret");
    add_randomized_unit("Nuke");
    add_randomized_unit("PlanetaryFortress");
    add_randomized_unit("Raven");
    add_randomized_unit("Reaper");
    add_randomized_unit_linked("SiegeTank", "SiegeTankSieged");
    add_randomized_unit_linked("Thor", "ThorAP");
    add_randomized_unit_linked("VikingFighter", "VikingAssault");
    add_randomized_unit_burrow("WidowMine");

    // Zerg Units, add_randomized_unit_burrow means there's a Burrowed version of the unit too
    add_randomized_unit_burrow("Baneling");
    link_unit("Baneling", "BanelingCocoon");
    add_randomized_unit("Broodling");
    add_randomized_unit("BroodLord");
    add_randomized_unit("Corruptor");
    add_randomized_unit_burrow("Hydralisk");
    add_randomized_unit_burrow("Infestor");
    add_randomized_unit_linked("LocustMP", "LocustMPFlying");
    add_randomized_unit_burrow("LurkerMP");
    link_unit("LurkerMP", "LurkerMPEgg");
    add_randomized_unit("Mutalisk");
    add_randomized_unit("NydusCanal");
    add_randomized_unit("OverlordTransport");
    add_randomized_unit_linked("Overseer", "OverlordCocoon");
    link_unit("Overseer", "OverseerSiegeMode");
    add_randomized_unit_burrow("Queen");
    add_randomized_unit_burrow("Ravager");
    link_unit("Ravager", "RavagerCocoon");
    add_randomized_unit_burrow("Roach");
    add_randomized_unit_linked("SpineCrawler", "SpineCrawlerUprooted");
    add_randomized_unit_linked("SporeCrawler", "SporeCrawlerUprooted");
    add_randomized_unit_linked("SwarmHostMP", "SwarmHostBurrowedMP");
    add_randomized_unit_burrow("Ultralisk");
    add_randomized_unit("Viper");
    add_randomized_unit_burrow("Zergling");


    // Buildings
    // Protoss Buildings
    add_randomized_building("CyberneticsCore");
    add_randomized_building("DarkShrine");
    add_randomized_building("FleetBeacon");
    add_randomized_building("Forge");
    add_randomized_building_linked("Gateway", "WarpGate");
    add_randomized_building("RoboticsBay");
    add_randomized_building("RoboticsFacility");
    add_randomized_building("Stargate");
    add_randomized_building("TemplarArchive");
    add_randomized_building("TwilightCouncil");

    // Terran Buildings
    add_randomized_building("Armory");
    add_randomized_building_linked("Barracks", "BarracksFlying");
    add_randomized_building("BarracksReactor");
    add_randomized_building("BarracksTechLab");
    add_randomized_building("EngineeringBay");
    add_randomized_building_linked("Factory", "FactoryFlying");
    add_randomized_building("FactoryReactor");
    add_randomized_building("FactoryTechLab");
    add_randomized_building("FusionCore");
    add_randomized_building("GhostAcademy");
    add_randomized_building("SensorTower");
    add_randomized_building_linked("Starport", "StarportFlying");
    add_randomized_building("StarportReactor");
    add_randomized_building("StarportTechLab");

    // Zerg Buildings
    add_randomized_building("BanelingNest");
    add_randomized_building("EvolutionChamber");
    add_randomized_building("GreaterSpire");
    add_randomized_building("Hive");
    add_randomized_building("HydraliskDen");
    add_randomized_building("InfestationPit");
    add_randomized_building("Lair");
    add_randomized_building("LurkerDenMP");
    add_randomized_building("RoachWarren");
    add_randomized_building("SpawningPool");
    add_randomized_building("Spire");
    add_randomized_building("UltraliskCavern");


    // CUnit
    AddRandomizedField("CUnit", type_int, "CostResource[Minerals]");
    AddRandomizedField("CUnit", type_int, "CostResource[Vespene]");
    AddRandomizedField("CUnit", type_int, "Food");
    AddRandomizedField("CUnit", type_int, "LifeMax");
    AddRandomizedField("CUnit", type_int, "ShieldsMax");
    AddRandomizedField("CUnit", type_int, "EnergyMax");
    //AddRandomizedField("CUnit", type_fixed, "Acceleration");
    AddRandomizedField("CUnit", type_fixed, "Speed");
    AddRandomizedFieldArray("CUnit", type_struct, "AbilArray");
    AddRandomizedFieldArray("CUnit", type_struct, "WeaponArray");
    
    AddRandomizedField("CUnitBuilding", type_int, "CostResource[Minerals]");
    AddRandomizedField("CUnitBuilding", type_int, "CostResource[Vespene]");
    AddRandomizedFieldArray("CUnitBuilding", type_struct, "AbilArray");

    // Weapons
    AddRandomizedField("CWeaponLegacy", type_fixed, "Range");
    AddRandomizedField("CWeaponLegacy", type_fixed, "Period");
    AddRandomizedField("CWeaponLegacy", type_effect, "DisplayEffect");
    AddRandomizedField("CWeaponStrafe", type_fixed, "Range");
    AddRandomizedField("CWeaponStrafe", type_fixed, "Period");
    AddRandomizedField("CWeaponStrafe", type_effect, "DisplayEffect");

    // Effects
    AddRandomizedField("CEffectDamage", type_int, "Amount");
    AddRandomizedField("CEffectCreatePersistent", type_effect, "InitialEffect");
    AddRandomizedField("CEffectCreatePersistent", type_effect, "AINotifyEffect");
    AddRandomizedField("CEffectCreatePersistent", type_int, "PeriodCount");
    AddRandomizedFieldArray("CEffectCreatePersistent", type_effect, "PeriodicEffectArray");
    AddRandomizedFieldArray("CEffectCreatePersistent", type_fixed, "PeriodicPeriodArray");
    AddRandomizedFieldArray("CEffectEnumArea", type_struct, "AreaArray");
    AddRandomizedField("CEffectApplyBehavior", type_behavior, "Behavior");
    AddRandomizedFieldArray("CEffectSet", type_behavior, "EffectArray");
    AddRandomizedField("CEffectTeleport", type_behavior, "PlacementRange");
    AddRandomizedField("CEffectTeleport", type_behavior, "Range");

    // Abilities
    AddRandomizedFieldArray("CAbilBuild", type_struct, "InfoArray");
    AddRandomizedField("CAbilBuild", type_int, "Range");
    AddRandomizedFieldArray("CAbilBuild", type_effect, "EffectArray");

    AddRandomizedFieldArray("CAbilResearch", type_struct, "InfoArray");

    AddRandomizedFieldArray("CAbilEffectInstant", type_effect, "Effect");
    AddRandomizedField("CAbilEffectInstant", type_effect, "AINotifyEffect");
    AddRandomizedFieldArray("CAbilEffectInstant", type_struct, "Cost");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "CastIntroTime");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "PrepTime");
    AddRandomizedField("CAbilEffectInstant", type_fixed, "AutoCastRange");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "Range");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "FinishTime");
    AddRandomizedField("CAbilEffectInstant", type_int, "Arc");

    AddRandomizedFieldArray("CAbilTrain", type_struct, "InfoArray");

    AddRandomizedFieldArray("CAbilArmMagazine", type_struct, "InfoArray");
    AddRandomizedField("CAbilArmMagazine", type_struct, "Cost");

    AddRandomizedFieldArray("CAbilWarpTrain", type_struct, "InfoArray");

    //AddRandomizedFieldArray("CAbilMorph", type_struct, "InfoArray");
    AddRandomizedField("CAbilMorph", type_struct, "Cost");

    //AddRandomizedFieldArray("CAbilMorphPlacement", type_struct, "InfoArray");
    AddRandomizedField("CAbilMorphPlacement", type_struct, "Cost");

    AddRandomizedField("CAbilBehavior", type_struct, "Cost");
    AddRandomizedFieldArray("CAbilBehavior", type_behavior, "BehaviorArray");

    AddRandomizedField("CAbilMerge", type_struct, "Info");

    AddRandomizedField("CAbilAugment", type_struct, "Cost");
    AddRandomizedField("CAbilAugment", type_effect, "Effect");

    AddRandomizedFieldArray("CAbilEffectTarget", type_struct, "Cost");
    AddRandomizedFieldArray("CAbilEffectTarget", type_effect, "Effect");
    AddRandomizedFieldArray("CAbilEffectTarget", type_int, "FinishTime");
    AddRandomizedFieldArray("CAbilEffectTarget", type_int, "Range");

    //AddRandomizedField("CAbilTransport", type_int, "MaxCargoCount");
    //AddRandomizedField("CAbilTransport", type_int, "MaxCargoSize");
    AddRandomizedField("CAbilTransport", type_int, "TotalCargoSpace");
    AddRandomizedField("CAbilTransport", type_fixed, "UnloadPeriod");
    //AddRandomizedField("CAbilTransport", type_int, "MaxUnloadRange");
    AddRandomizedField("CAbilTransport", type_int, "Range");
    //AddRandomizedField("CAbilTransport", type_int, "SearchRadius");

    // Behaviors
    AddRandomizedField("CBehaviorBuff", type_effect, "InitialEffect");
    AddRandomizedField("CBehaviorBuff", type_effect, "PeriodicEffect");
    AddRandomizedField("CBehaviorBuff", type_effect, "AINotifyEffect");
    AddRandomizedFieldArray("CBehaviorBuff", type_effect, "PeriodicDisplayEffect");
    AddRandomizedField("CBehaviorBuff", type_fixed, "Duration");
    AddRandomizedField("CBehaviorBuff", type_fixed, "Period");
    AddRandomizedField("CBehaviorBuff", type_struct, "Cost");

    // Upgrades
    //AddRandomizedFieldArray("CUpgrade", type_unknown, "EffectArray");

    // structs
    AddRandomizedField("SCost", type_int, ".Cooldown.TimeStart");
    AddRandomizedField("SCost", type_int, ".Cooldown.TimeUse");
    AddRandomizedField("SCost", type_int, ".Resource[Minerals]");
    AddRandomizedField("SCost", type_int, ".Resource[Vespene]");
    AddRandomizedField("SCost", type_int, ".Vital[Life]");
    AddRandomizedField("SCost", type_int, ".Vital[Shields]");
    AddRandomizedField("SCost", type_int, ".Vital[Energy]");

    AddRandomizedFieldFriendlyName("SAbilBuildInfo", type_int, ".Time", ".Unit");
    CopyRandomizedFields("SCost", "SAbilBuildInfo", ".Unit");

    AddRandomizedFieldFriendlyName("SAbilResearchInfo", type_int, ".Time", ".Upgrade");
    AddRandomizedField("SAbilResearchInfo", type_upgrade, ".Upgrade");
    CopyRandomizedFields("SCost", "SAbilResearchInfo", ".Upgrade");

    AddRandomizedFieldFriendlyName("SAbilTrainInfo", type_int, ".Time", ".Unit[0]");
    AddRandomizedField("SAbilTrainInfo", type_effect, ".Effect");
    CopyRandomizedFields("SCost", "SAbilTrainInfo", ".Unit[0]");// TODO: idk if this is needed

    AddRandomizedField("SUnitAbilData", type_ability, ".Link");
    AddRandomizedField("SUnitWeaponData", type_weapon, ".Link");

    AddRandomizedFieldFriendlyName("SAbilArmMagazineInfo", type_int, ".Time", ".Unit");
    CopyRandomizedFields("SCost", "SAbilArmMagazineInfo", ".Unit");

    AddRandomizedFieldFriendlyName("SAbilWarpTrainInfo", type_int, ".Time", ".Unit");
    CopyRandomizedFields("SCost", "SAbilWarpTrainInfo", ".Unit");

    AddRandomizedField("SEffectEnumArea", type_effect, ".Effect");
    AddRandomizedField("SEffectEnumArea", type_fixed, ".Radius");

    create_dialog_start();
}
// #endregion
