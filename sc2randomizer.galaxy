include "TriggerLibs/NativeLib"

// https://mapster.talv.space/galaxy/reference#catalog
// https://sc2mapster.fandom.com/wiki/Tutorials

//string number_types;
fixed min_percent;
fixed max_percent;
int seed;
int changes_per_race;
int changes_per_unit;

struct Change {
    string entry;
    string field;
    fixed oldval;
    fixed newval;
};

struct RaceChanges {
    string name;
    Change[1024] changes;
    int len;
};
const int no_race=0;
const int terran=1;
const int protoss=2;
const int zerg=3;
RaceChanges[4] race_changes;

struct RandomizedField {
    //int cat;
    int type;
    string scope;
    string name;
    bool is_array;
};
RandomizedField[1024] randomized_fields;
const int type_unknown = 0;
const int type_fixed = 1;
const int type_int = 2;
// scopes
const int type_unit = 3;
const int type_ability = 4;
const int type_effect = 5;
const int type_weapon = 6;
const int type_upgrade = 7;
const int type_behavior = 8;

const int type_struct = 100;

void debug(string message)
{
    //TriggerDebugOutput(1, StringToText(message), false );
}

void info(string message)
{
    TriggerDebugOutput(1, StringToText(message), false );
}

void warning(string message)
{
    TriggerDebugOutput(1, StringToText(message), false );
}

void error(string message)
{
    TriggerDebugOutput(1, StringToText(message), false );
}

void fatal(string message)
{
    TriggerDebugOutput(1, StringToText(message), false );
}

void AddRandomizedField(string scope, int type, string name)
{
    int i;
    for( i=0; i<1024; i+=1 ) {
        if( randomized_fields[i].name == "" ) {
            randomized_fields[i].scope = scope;
            randomized_fields[i].type = type;
            randomized_fields[i].name = name;
            randomized_fields[i].is_array = false;
            return;
        }
    }
}

void AddRandomizedFieldArray(string scope, int type, string name)
{
    int i;
    for( i=0; i<1024; i+=1 ) {
        if( randomized_fields[i].name == "" ) {
            randomized_fields[i].scope = scope;
            randomized_fields[i].type = type;
            randomized_fields[i].name = name;
            randomized_fields[i].is_array = true;
            return;
        }
    }
}

void CopyRandomizedFields(string from, string scope)
{
    int i;
    for( i=0; i<1024; i+=1 ) {
        if( randomized_fields[i].scope == from ) {
            if( randomized_fields[i].is_array ) {
                AddRandomizedFieldArray(scope, randomized_fields[i].type, randomized_fields[i].name);
            }
            else {
                AddRandomizedField(scope, randomized_fields[i].type, randomized_fields[i].name);
            }
        }
    }
}

int GetRandomField(string scope)
{
    int num;
    int i;

    num = 0;
    for( i=0; i<1024; i+=1 ) {
        if( randomized_fields[i].scope == scope && randomized_fields[i].name != "" ) {
            num+=1;
        }
    }

    if( num == 0 ) {
        return -1;
    }

    num = RandomInt(0, num-1);
    for( i=0; i<1024; i+=1 ) {
        if( randomized_fields[i].scope == scope && randomized_fields[i].name != "" ) {
            if( num == 0 ) {
                return i;
            }
            num-=1;
        }
    }

    return -1;
}

string[100] notes;
bool note_add(string val)
{
    int i;
    for( i=0; i<100; i+=1 ) {
        if( notes[i] == val ) {
            return false;
        }
        if( notes[i] == "" ) {
            info("note_add "+val);
            notes[i] = val;
            return true;
        }
    }
    return false;
}

void notes_log()
{
    int i;
    for( i=0; i<100; i+=1 ) {
        if( notes[i] == "" ) {
            continue;
        }
        TriggerDebugOutput(1, StringToText(notes[i]), false );
    }
}


int find_change(int self, string entry, string field)
{
    int i;
    for( i=0; i < race_changes[self].len; i+=1 ) {
        if( race_changes[self].changes[i].entry == entry && race_changes[self].changes[i].field == field ) {
            return i;
        }
    }
    return -1;
}

bool add_change(int self, string entry, string field, fixed oldval, fixed newval)
{
    int len;

    len = race_changes[self].len;
    if( len >= 1024 ) {
        error("add_change failed with "+entry+" "+field+" changing from "+FixedToString(oldval,5)+" to "+FixedToString(newval,5));
        return false;
    }
    race_changes[self].changes[len].entry = entry;
    race_changes[self].changes[len].field = field;
    race_changes[self].changes[len].oldval = oldval;
    race_changes[self].changes[len].newval = newval;
    race_changes[self].len += 1;

    //message = "add_change with "+entry+" "+field+" changing from "+FixedToString(oldval,5)+" to "+FixedToString(newval,5);
    //TriggerDebugOutput(1, StringToText(message), false );

    return true;
}

void log_changes(int self)
{
    int i;
    string message;

    message = race_changes[self].name + " Changes: ";

    for( i=0; i < race_changes[self].len; i+=1 ) {
        if( i > 0 ) {
            message += ", ";
        }
        message +=
            race_changes[self].changes[i].entry+" "+race_changes[self].changes[i].field
            + " changed from "
            + FixedToString(race_changes[self].changes[i].oldval,5)
            + " to "+FixedToString(race_changes[self].changes[i].newval,5);

        if( StringLength(message) > 200 ) {
            info( message );
            message = "--- ";
        }
    }

    if( message != "" ) {
        info( message );
    }

    //UIDisplayMessage( PlayerGroupAll(), c_messageAreaChat, StringToText(message) );
    //UIShowTextCrawl( PlayerGroupAll(), StringToText(race_changes[self].name + " Changes: "), StringToText(message), 6, SoundLink("Silent", -1), SoundLink("Silent", -1));
    // https://mapster.talv.space/galaxy/reference/dialog-create
    // https://mapster.talv.space/galaxy/reference#dialog-dialog-items
}

fixed rng(fixed min, fixed max) {
    return RandomFixed(min, max);
}

fixed randomize(fixed val) {
    fixed percent;
    // probably should make all changes far away from 100%, since there will be few things changed
    percent = rng(min_percent, max_percent);
    if( (percent - min_percent) < (max_percent - percent) ) {
        percent = (percent+min_percent) / 2.0;
    } else {
        percent = (percent+max_percent) / 2.0;
    }
    return val * percent / 100.0;
}


bool set_field_string(int cat, string entry, string field, string value)
{
    playergroup allplayers;
    int player;
    int num_players;
    int i;

    allplayers = PlayerGroupAll();
    num_players = PlayerGroupCount(allplayers);
    for( i=1; i<=num_players; i+=1 ) {
        player = PlayerGroupPlayer( allplayers, i );
        if( ! CatalogFieldValueSet(cat, entry, field, player, value) ) {
            return false;
        }
    }
    return true;
}


bool set_field_fixed(int cat, string entry, string field, fixed value)
{
    playergroup allplayers;
    int player;
    int num_players;
    int i;
    allplayers = PlayerGroupAll();
    num_players = PlayerGroupCount(allplayers);
    for( i=1; i<=num_players; i+=1 ) {
        player = PlayerGroupPlayer( allplayers, i );
        if( ! libNtve_gf_CatalogFieldValueSetAsReal(cat, entry, field, player, value) ) {
            return false;
        }
    }
    return true;
}


bool rando_field_fixed(int cat, string entry, string field, int changes_id)
{
    fixed getval;
    fixed setval;
    fixed value;

    if( find_change(changes_id, entry, field) != -1 ) {
        return false;
    }

    getval = libNtve_gf_CatalogFieldValueGetAsReal(cat, entry, field, 1);
    if( getval == 0 ) {
        debug(entry+" "+field+" failed to read");
        return false;
    }
    value = randomize(getval);
    if( value == getval ) {
        return false;
    }
    if( ! set_field_fixed(cat, entry, field, value ) ) {
        error(entry+" "+field+" was "+FixedToString(getval,5)+", failed to change to "+FixedToString(value,5));
        return false;
    }
    setval = libNtve_gf_CatalogFieldValueGetAsReal(cat, entry, field, 1);
    if( getval == setval ) { return false; }

    add_change(changes_id, entry, field, getval, setval);// TODO: maybe need to save the type too, and a friendly name

    if( field == "LifeMax" ) {// TODO: maybe need a list of linked values to keep proportional instead of hardcoded
        if( ! set_field_fixed(cat, entry, "LifeStart", value) ) {
            error(entry+" LifeStart failed to set to "+FixedToString(value,5));
            return false;
        }
    }
    if( field == "ShieldsMax" ) {
        if( ! set_field_fixed(cat, entry, "ShieldsStart", value) ) {
            error(entry+" ShieldsStart failed to set to "+FixedToString(value,5));
            return false;
        }
    }
    return true;
}


bool rando_field_int(int cat, string entry, string field, int changes_id)
{
    int getval;
    int setval;
    int value;

    if( find_change(changes_id, entry, field) != -1 ) {
        return false;
    }

    getval = CatalogFieldValueGetAsInt(cat, entry, field, 1);
    if( getval == 0 ) {
        debug(entry+" "+field+" failed to read");
        return false;
    }
    value = FixedToInt( randomize(getval) );
    if( value == getval ) {
        return false;
    }
    if( ! set_field_string(cat, entry, field, IntToString(value) ) ) {
        error(entry+" "+field+" was "+IntToString(getval)+", failed to change to "+IntToString(value));
        return false;
    }
    setval = CatalogFieldValueGetAsInt(cat, entry, field, 1);
    if( getval == setval ) { return false; }

    add_change(changes_id, entry, field, getval, setval);

    if( field == "LifeMax" ) {
        if( ! set_field_fixed(cat, entry, "LifeStart", value) ) {
            error(entry+" LifeStart failed to set to "+FixedToString(value,5));
            return false;
        }
    }
    if( field == "ShieldsMax" ) {
        if( ! set_field_fixed(cat, entry, "ShieldsStart", value) ) {
            error(entry+" ShieldsStart failed to set to "+FixedToString(value,5));
            return false;
        }
    }
    return true;
}


int get_race_id(int cat, string scope, string entry) {
    string EditorCategories;
    string race;

    if( CatalogFieldExists(scope, "EditorCategories") ) {
        EditorCategories = CatalogFieldValueGet(cat, entry, "EditorCategories", 1);
        if( ! StringContains(EditorCategories, "ObjectFamily:Melee", c_stringAnywhere, c_stringCase) ) {
            return no_race;
        }
    } else {
        EditorCategories = "";
    }

    if( CatalogFieldExists(scope, "Race") ) {
        race = "Race:" + CatalogFieldValueGet(cat, entry, "Race", 1);
    }
    else {
        race = EditorCategories;
    }

    if( StringContains(race, "Race:Terr", c_stringAnywhere, c_stringCase) ) {
        return terran;
    }
    else if( StringContains(race, "Race:Prot", c_stringAnywhere, c_stringCase) ) {
        return protoss;
    }
    else if( StringContains(race, "Race:Zerg", c_stringAnywhere, c_stringCase) ) {
        return zerg;
    }
    
    return no_race;
}


void modify_resources(string name, fixed percent) {
    int i;
    int num;
    int val;
    unitgroup units;
    unit u;

    units = UnitGroup(name, 0, RegionEntireMap(), UnitFilter(0,0,0,0), 99999 );
    num = UnitGroupCount(units, c_unitCountAll);
    debug("found "+IntToString(num)+" of "+name);
    for( i=0; i<num; i+=1 ) {
        u = UnitGroupUnit(units, i);
        val = UnitGetPropertyInt(u, c_unitPropResources, true);
        val = FixedToInt(IntToFixed(val) * percent / 100.0);
        UnitSetPropertyInt(u, c_unitPropResources, val);
    }
}


void modify_behavior_resource(string name, fixed amount_percent, fixed amount, fixed time) {
    fixed val;

    // TODO:
    // Catalog field 'HarvestAmount' could not be written (Core: access denied to required object or service)
    // Catalog field 'HarvestTime' could not be written (Core: access denied to required object or service)
    // Catalog field 'Capacity' could not be written (Core: access denied to required object or service)
    // Catalog field 'Contents' could not be written (Core: access denied to required object or service)
    return;

    val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "HarvestAmount", 1);
    val = val * amount / 100.0;
    set_field_fixed(c_gameCatalogBehavior, name, "HarvestAmount", val );

    val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "HarvestTime", 1);
    val = val * time / 100.0;
    set_field_fixed(c_gameCatalogBehavior, name, "HarvestTime", val );

    val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "Capacity", 1);
    val = val * amount_percent / 100.0;
    set_field_string(c_gameCatalogBehavior, name, "Capacity", FixedToString(val,0) );

    val = libNtve_gf_CatalogFieldValueGetAsReal(c_gameCatalogBehavior, name, "Contents", 1);
    val = val * amount_percent / 100.0;
    set_field_string(c_gameCatalogBehavior, name, "Contents", FixedToString(val,0) );
}


void randomize_economy() {
    fixed amount_percent;
    fixed harvestamount_percent;
    fixed harvesttime_percent;
    //fixed delay_percent;

    // CBehaviorResource minerals
    amount_percent = randomize(100);
    harvestamount_percent = randomize(100);
    harvesttime_percent = randomize(100);
    modify_behavior_resource("HighYieldMineralFieldMinerals", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HighYieldMineralFieldMinerals750", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMinerals", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMinerals450", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMinerals750", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMineralsNoRemove", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMineralsOpaque", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("MineralFieldMineralsOpaque900", amount_percent, harvestamount_percent, harvesttime_percent);
    //add_change(no_race, "Minerals Harvest", "Amount", 5, 5.0*harvestamount_percent/100);
    //add_change(no_race, "Minerals Harvest", "Time", 2.786, 2.786*harvesttime_percent/100);

    // minerals
    modify_resources("MineralField", amount_percent);
    modify_resources("MineralField450", amount_percent);
    modify_resources("MineralField750", amount_percent);
    modify_resources("LabMineralField", amount_percent);
    modify_resources("LabMineralField750", amount_percent);
    modify_resources("BattleStationMineralField", amount_percent);
    modify_resources("BattleStationMineralField750", amount_percent);
    modify_resources("MineralFieldDefault", amount_percent);
    modify_resources("MineralFieldOpaque", amount_percent);
    modify_resources("MineralFieldOpaque900", amount_percent);
    modify_resources("PurifierMineralField", amount_percent);
    modify_resources("PurifierMineralField750", amount_percent);
    modify_resources("PurifierRichMineralField", amount_percent);
    modify_resources("PurifierRichMineralField750", amount_percent);
    modify_resources("RichMineralField", amount_percent);
    modify_resources("RichMineralField750", amount_percent);
    modify_resources("RichMineralFieldDefault", amount_percent);
    add_change(no_race, "Minerals", "%", 100, amount_percent);

    // CBehaviorResource gas
    amount_percent = randomize(100);
    harvestamount_percent = randomize(100);
    harvesttime_percent = randomize(100);
    modify_behavior_resource("HarvestableRichVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableRichVespeneGeyserGasProtoss", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableRichVespeneGeyserGasZerg", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableTerrazineGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableTerrazineGeyserGasProtoss", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableTerrazineGeyserGasZerg", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableVespeneGeyserGasProtoss", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("HarvestableVespeneGeyserGasZerg", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("RawRichVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("RawTerrazineGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    modify_behavior_resource("RawVespeneGeyserGas", amount_percent, harvestamount_percent, harvesttime_percent);
    //add_change(no_race, "Gas Harvest", "Amount", 4, 4.0*harvestamount_percent/100);
    //add_change(no_race, "Gas Harvest", "Time", 1.981, 1.981*harvesttime_percent/100);

    // gasses
    modify_resources("ProtossVespeneGeyser", amount_percent);
    modify_resources("PurifierVespeneGeyser", amount_percent);
    modify_resources("RichVespeneGeyser", amount_percent);
    modify_resources("ShakurasVespeneGeyser", amount_percent);
    modify_resources("SpacePlatformGeyser", amount_percent);
    modify_resources("VespeneGeyser", amount_percent);
    add_change(no_race, "Gas", "%", 100, amount_percent);

    // TODO: for some reason it's able to read the starting workers, but trying to write them says
    // Catalog field 'StartingUnitArray[1].Count' could not be written (Core: access denied to required object or service)
    //for( i=0; i<16; i+=1 ) {
    //    info("Terr "+CatalogFieldValueGet(c_gameCatalogRace, "Terr", "StartingUnitArray[1].Count", i ));
    //    CatalogFieldValueSet(c_gameCatalogRace, "Terr", "StartingUnitArray[1].Count", i, IntToString(i) );
    //    info("Prot "+CatalogFieldValueGet(c_gameCatalogRace, "Prot", "StartingUnitArray[1].Count", i ));
    //    CatalogFieldValueSet(c_gameCatalogRace, "Prot", "StartingUnitArray[1].Count", i, IntToString(i) );
    //    info("Zerg "+CatalogFieldValueGet(c_gameCatalogRace, "Zerg", "StartingUnitArray[1].Count", i ));
    //    CatalogFieldValueSet(c_gameCatalogRace, "Zerg", "StartingUnitArray[1].Count", i, IntToString(i) );
    //}
}


int randomize_field(int cat, string scope, string entry, string field, string val, int type, string field_type, int race_id, int num_fields );
int randomize_behavior(string entry, int race_id, int num_fields);
int randomize_effect(string entry, int race_id, int num_fields);
int randomize_weapon(string entry, int race_id, int num_fields);
int randomize_upgrade(string entry, int race_id, int num_fields);
int randomize_ability(string entry, int race_id, int num_fields);
int randomize_unit(string entry, int race_id, int num_fields);


int randomize_fields(int cat, string scope, string entry, string prefix, int race_id, int num_fields) {
    int i;
    int k;
    int slot;
    int num;
    bool[1024] mask;
    int len;
    string field;
    string val;
    int type;
    string field_type;

    debug("randomize_fields("+IntToString(cat)+", "+scope+", "+entry+", "+prefix+")");

    num = 0;
    for( i=0; num<num_fields && i<32; i+=1 ) {
        slot = GetRandomField(scope);
        if( slot == -1 ) {
            if( num==0 ) {
                debug(scope+" "+entry+" GetRandomField failed");
                note_add(scope+" GetRandomField failed");
            }
            return num;
        }
        if( mask[slot] ) { continue; }
        mask[slot] = true;

        field = randomized_fields[slot].name;
        type = randomized_fields[slot].type;
        // will need this if I want to use randomize_fields for calling randomize_ability and stuff like that
        if( randomized_fields[slot].is_array ) {
            len = CatalogFieldValueCount(cat, entry, prefix+field, 1);
            field_type = CatalogFieldType(scope, prefix+field);
            for( k=0; k<len; k+=1 ) {
                // need to pick random slot actually
                if( type != type_struct ) {
                    val = CatalogFieldValueGet(cat, entry, prefix+field+"["+IntToString(k)+"]", 1);
                    if( val == "" ) {
                        debug(scope+" "+entry+" failed CatalogFieldValueGet "+prefix+field+"["+IntToString(k)+"]");
                        continue;
                    }
                } else {
                    val = "";
                }
                num += randomize_field(cat, scope, entry, prefix+field+"["+IntToString(k)+"]", val, type, field_type, race_id, num_fields );
            }
        } else {
            if( type != type_struct ) {
                val = CatalogFieldValueGet(cat, entry, prefix+field, 1);
                if( val == "" ) {
                    debug(scope+" "+entry+" failed CatalogFieldValueGet "+prefix+field);
                    continue;
                }
            } else {
                val = "";
            }
            num += randomize_field(cat, scope, entry, prefix+field, val, type, "", race_id, num_fields );
        }
    }

    return num;
}


int randomize_behavior(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogBehavior;
    string scope;
    if( entry == "" ) {
        note_add("randomize_behavior empty entry");
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
    // Behavior PsiStorm is a CBehaviorBuff
}


int randomize_effect(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogEffect;
    string scope;
    if( entry == "" ) {
        note_add("randomize_effect empty entry");
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);

    // PsiStormPersistent is a CEffectCreatePersistent with a PeriodCount, PeriodEffectArray, PeriodicPeriodArray
    // PsiStormSearch is a CEffectEnumArea with a AreaArray[i].Radius, AreaArray[i].Effect
    // PsiStormApplyBehavior is a CEffectApplyBehavior with a Behavior == PsiStorm (a CBehaviorBuff)
    // PsiStormDamageInitial is a CEffectDamage with an Amount == 10, PsiStormDamage is the same

    // ArbiterMPRecallSet is a CEffectSet with an array EffectArray
    // ArbiterMPRecallTeleport is a CEffectTeleport with a PlacementRange of 15, Range of 1000
}


int randomize_weapon(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogWeapon;
    string scope;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);

    // CWeapon_DisplayEffect is where the damage is defined?

    // scopes
    // CWeaponLegacy has Period, Range, MinimumRange, MinScanRange, SCost Cost, 
    // InterceptorBeam is the only CWeaponStrafe with a Period, Range, Arc
}


int randomize_upgrade(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogUpgrade;
    string scope;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    // CUpgrade BattlecruiserBehemothReactor has <EffectArray Reference="Unit,Battlecruiser,EnergyStart" Value="25"/>
    // maybe if EffectArray[i].Operation is anything except Set, then it can be randomized
    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
}


int randomize_ability(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogAbil;
    string scope;
    string type;
    int len;
    int i;
    string val;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    scope = CatalogEntryScope(cat, entry);
    return randomize_fields(cat, scope, entry, "", race_id, num_fields);

    // scopes
    // CAbilBuild
    // CAbilMorphPlacement
    // CAbilMove
    // CAbilStop
    // CAbilBuildable
    // CAbilQueue
    // CAbilArmMagazine
    // CAbilResearch
    // CAbilMorph
    // CAbilAttack
    // CAbilWarpable
    // CAbilEffectTarget
    // CAbilTrain
    // CAbilRally
    // CAbilEffectInstant
    // CAbilAugment
    // CAbilMerge
    // CAbilTransport
    // CAbilMergeable
    // CAbilBehavior
    // CAbilRedirectInstant
    // CAbilRedirectTarget

    // BarracksTechLabMorph is a CAbilMorph with InfoArray SAbilMorphInfo, and with Cost SCost
    // FactoryLand is a CAbilMorphPlacement with InfoArray SAbilMorphInfo, and with Cost SCost
    // FactoryTechLabResearch is a CAbilResearch with InfoArray SAbilResearchInfo
        // with InfoArray[3].Upgrade == TerranInfantryWeaponsLevel1, .Time=160, .Resource[Minerals/Vespene]
    // Rally is a CAbilRally with InfoArray SAbilRallyInfo
    // BuildNydusCanal is a CAbilBuild with InfoArray SAbilBuildInfo has [i].Unit for unit name and [i].Time for build time
    // TrainQueen is a CAbilTrain with InfoArray SAbilTrainInfo
    // ArmSiloWithNuke is a CAbilArmMagazine with InfoArray SAbilArmMagazineInfo, and with Cost SCost
    // WarpGateTrain is a CAbilWarpTrain with InfoArray SAbilWarpTrainInfo

    // GhostCloak is a CAbilBehavior with Cost SCost
        // has an array of structs named Cost, Cost[i].Charge, .Cooldown.TimeStart, .Cooldown.TimeUse, .Vital.Life, .Vital.Shields, .Vital.Energy, .VitalFraction
    
    // ArchonWarp is a CAbilMerge with InfoArray 
        // Info is a SAbilMergeInfo with Info.Resource.Minerals/Vespene, Info.Time, Info.Unit==Archon, Info.Cooldown, Info.Vital, Info.VitalFraction (seems to be same type as a CAbilBehavior.Cost)
    
    // Charge is a CAbilAugment with Cost SCost
        // has struct Cooldown (probably same type as Cooldown in CAbilBehavior)

    // TacNukeStrike is a CAbilEffectTarget with Cost SCost
        // has arrays for Effect, FinishTime (fixed), Range (fixed or maybe int?)
    
    // NydusCanalTransport is a CAbilTransport with InfoArray 
        // has MaxCargoCount, MaxCargoSize, Range, TotalCargoSpace, UnloadPeriod

    // BuildInProgress is a CAbilBuildable with InfoArray 
    // que5Addon is a CAbilQueue with InfoArray 
    // stop is a CAbilStop with InfoArray 
    // attack is a CAbilAttack with InfoArray 
    // move is a CAbilMove with InfoArray 
    // GhostHoldFire is a CAbilEffectInstant with InfoArray 
    // StimpackRedirect is a CAbilRedirectInstant with InfoArray 
    // AttackRedirect is a CAbilRedirectTarget with InfoArray 
    // Warpable is a CAbilWarpable with InfoArray 
    // Mergeable is a CAbilMergeable with InfoArray 

    //type = CatalogFieldType(scope, "Cost");
    //if( note_add(scope) ) {
    //    note_add(entry+" is a "+scope+" with Cost "+type);
    //}
    //return 0;
}


int randomize_unit(string entry, int race_id, int num_fields) {
    int cat = c_gameCatalogUnit;
    string scope = "CUnit";
    int i;
    int len;
    int slot;
    string val;

    if( entry == "" ) {
        return 0;
    }
    if( ! CatalogEntryIsValid(cat, entry) ) {
        return 0;
    }

    return randomize_fields(cat, scope, entry, "", race_id, num_fields);
}


void randomize_units(int changes_per_race) {
    int cat = c_gameCatalogUnit;
    string scope = "CUnit";
    string entry;
    string cost_category;
    int num_data;
    int race_id;
    int i;
    int slot;

    num_data = CatalogEntryCount(cat);

    for( i=1; i<=num_data; i+=1 ) {

        if( race_changes[terran].len >= changes_per_race
            && race_changes[protoss].len >= changes_per_race
            && race_changes[zerg].len >= changes_per_race
        ) {
            break;
        }
        GameSetSeed( 5 + seed + i);
        slot = RandomInt(1, num_data);

        entry = CatalogEntryGet(cat, slot);
        race_id = get_race_id(cat, scope, entry);
        if( race_id == no_race ) {
            continue;
        }
        if( race_changes[race_id].len >= changes_per_race ) {
            continue;
        }

        cost_category = CatalogFieldValueGet(cat, entry, "CostCategory", 1);
        if( cost_category != "Army" && cost_category != "Technology" ) {
            continue;
        }

        GameSetSeed( 5 + seed + slot);
        randomize_unit(entry, race_id, changes_per_unit);
    }

    GameSetSeed(seed);
}


int randomize_field(int cat, string scope, string entry, string field, string val, int type, string field_type, int race_id, int num_fields ) {
    if( type == type_fixed ) {
        if( rando_field_fixed(cat, entry, field, race_id) ) {
            return 1;
        }
    }
    else if( type == type_int ) {
        if( rando_field_int(cat, entry, field, race_id) ) {
            return 1;
        }
    }
    else if( type == type_unit ) {
        return randomize_unit(val, race_id, num_fields);
    }
    else if( type == type_ability ) {
        return randomize_ability(val, race_id, num_fields);
    }
    else if( type == type_effect ) {
        return randomize_effect(val, race_id, num_fields);
    }
    else if( type == type_weapon ) {
        return randomize_weapon(val, race_id, num_fields);
    }
    else if( type == type_upgrade ) {
        return randomize_upgrade(val, race_id, num_fields);
    }
    else if( type == type_behavior ) {
        return randomize_behavior(val, race_id, num_fields);
    }
    else if( type == type_struct ) {
        if( field_type == "" ) {
            field_type = CatalogFieldType(scope, field);
        }
        return randomize_fields(cat, field_type, entry, field, race_id, num_fields);
    }
    else {
        if( field_type == "" ) {
            field_type = CatalogFieldType(CatalogEntryScope(cat, entry), field);
        }
        info(scope+" "+entry+" has "+field_type+" ("+IntToString(type)+") "+field+", value: "+val );
        note_add(scope+" has "+field_type+" ("+IntToString(type)+") "+field+", value: "+val );
        return 0;
    }

    return 0;
}


void main () {
    bool seed_was_locked;
    int oldseed;
    //int changes_per_category;
    int i;

    seed=1337;
    min_percent = 50;
    max_percent = 150;
    changes_per_race = 50;
    changes_per_unit = 2;
    
    // CUnit
    AddRandomizedField("CUnit", type_int, "CostResource[Minerals]");
    AddRandomizedField("CUnit", type_int, "CostResource[Vespene]");
    AddRandomizedField("CUnit", type_int, "Food");
    AddRandomizedField("CUnit", type_int, "LifeMax");
    AddRandomizedField("CUnit", type_int, "ShieldsMax");
    AddRandomizedField("CUnit", type_int, "EnergyMax");
    //AddRandomizedField("CUnit", type_fixed, "Acceleration");
    AddRandomizedField("CUnit", type_fixed, "Speed");
    AddRandomizedFieldArray("CUnit", type_struct, "AbilArray");
    AddRandomizedFieldArray("CUnit", type_struct, "WeaponArray");

    // Weapons
    AddRandomizedField("CWeaponLegacy", type_fixed, "Range");
    AddRandomizedField("CWeaponLegacy", type_fixed, "Period");
    AddRandomizedField("CWeaponLegacy", type_effect, "DisplayEffect");
    AddRandomizedField("CWeaponStrafe", type_fixed, "Range");
    AddRandomizedField("CWeaponStrafe", type_fixed, "Period");
    AddRandomizedField("CWeaponStrafe", type_effect, "DisplayEffect");

    // Effects
    AddRandomizedField("CEffectDamage", type_int, "Amount");
    AddRandomizedField("CEffectCreatePersistent", type_effect, "InitialEffect");
    AddRandomizedField("CEffectCreatePersistent", type_effect, "AINotifyEffect");
    AddRandomizedField("CEffectCreatePersistent", type_int, "PeriodCount");
    AddRandomizedFieldArray("CEffectCreatePersistent", type_effect, "PeriodicEffectArray");
    AddRandomizedFieldArray("CEffectCreatePersistent", type_fixed, "PeriodicPeriodArray");
    AddRandomizedFieldArray("CEffectEnumArea", type_struct, "AreaArray");
    AddRandomizedField("CEffectApplyBehavior", type_behavior, "Behavior");
    AddRandomizedFieldArray("CEffectSet", type_behavior, "EffectArray");
    AddRandomizedField("CEffectTeleport", type_behavior, "PlacementRange");
    AddRandomizedField("CEffectTeleport", type_behavior, "Range");

    // Abilities
    AddRandomizedFieldArray("CAbilBuild", type_struct, "InfoArray");
    AddRandomizedField("CAbilBuild", type_int, "Range");
    AddRandomizedFieldArray("CAbilBuild", type_effect, "EffectArray");

    AddRandomizedFieldArray("CAbilResearch", type_struct, "InfoArray");

    AddRandomizedFieldArray("CAbilEffectInstant", type_effect, "Effect");
    AddRandomizedField("CAbilEffectInstant", type_effect, "AINotifyEffect");
    AddRandomizedFieldArray("CAbilEffectInstant", type_struct, "Cost");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "CastIntroTime");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "PrepTime");
    AddRandomizedField("CAbilEffectInstant", type_fixed, "AutoCastRange");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "Range");
    AddRandomizedFieldArray("CAbilEffectInstant", type_int, "FinishTime");
    AddRandomizedField("CAbilEffectInstant", type_int, "Arc");

    AddRandomizedFieldArray("CAbilTrain", type_struct, "InfoArray");

    AddRandomizedFieldArray("CAbilArmMagazine", type_struct, "InfoArray");
    AddRandomizedField("CAbilArmMagazine", type_struct, "Cost");

    AddRandomizedFieldArray("CAbilWarpTrain", type_struct, "InfoArray");

    //AddRandomizedFieldArray("CAbilMorph", type_struct, "InfoArray");
    AddRandomizedField("CAbilMorph", type_struct, "Cost");

    //AddRandomizedFieldArray("CAbilMorphPlacement", type_struct, "InfoArray");
    AddRandomizedField("CAbilMorphPlacement", type_struct, "Cost");

    AddRandomizedField("CAbilBehavior", type_struct, "Cost");
    AddRandomizedFieldArray("CAbilBehavior", type_behavior, "BehaviorArray");

    AddRandomizedField("CAbilMerge", type_struct, "Info");

    AddRandomizedField("CAbilAugment", type_struct, "Cost");
    AddRandomizedField("CAbilAugment", type_effect, "Effect");

    AddRandomizedFieldArray("CAbilEffectTarget", type_struct, "Cost");
    AddRandomizedFieldArray("CAbilEffectTarget", type_effect, "Effect");
    AddRandomizedFieldArray("CAbilEffectTarget", type_int, "FinishTime");
    AddRandomizedFieldArray("CAbilEffectTarget", type_int, "Range");

    //AddRandomizedField("CAbilTransport", type_int, "MaxCargoCount");
    //AddRandomizedField("CAbilTransport", type_int, "MaxCargoSize");
    AddRandomizedField("CAbilTransport", type_int, "TotalCargoSpace");
    AddRandomizedField("CAbilTransport", type_fixed, "UnloadPeriod");
    //AddRandomizedField("CAbilTransport", type_int, "MaxUnloadRange");
    AddRandomizedField("CAbilTransport", type_int, "Range");
    //AddRandomizedField("CAbilTransport", type_int, "SearchRadius");

    // Behaviors
    AddRandomizedField("CBehaviorBuff", type_effect, "InitialEffect");
    AddRandomizedField("CBehaviorBuff", type_effect, "PeriodicEffect");
    AddRandomizedField("CBehaviorBuff", type_effect, "AINotifyEffect");
    AddRandomizedFieldArray("CBehaviorBuff", type_effect, "PeriodicDisplayEffect");
    AddRandomizedField("CBehaviorBuff", type_fixed, "Duration");
    AddRandomizedField("CBehaviorBuff", type_fixed, "Period");
    AddRandomizedField("CBehaviorBuff", type_struct, "Cost");

    // Upgrades
    //AddRandomizedFieldArray("CUpgrade", type_unknown, "EffectArray");

    // structs
    AddRandomizedField("SCost", type_int, ".Cooldown.TimeStart");
    AddRandomizedField("SCost", type_int, ".Cooldown.TimeUse");
    AddRandomizedField("SCost", type_int, ".Resource[Minerals]");
    AddRandomizedField("SCost", type_int, ".Resource[Vespene]");
    AddRandomizedField("SCost", type_int, ".Vital[Life]");
    AddRandomizedField("SCost", type_int, ".Vital[Shields]");
    AddRandomizedField("SCost", type_int, ".Vital[Energy]");

    AddRandomizedField("SAbilBuildInfo", type_int, ".Time");// we need the .Unit for the friendly name
    CopyRandomizedFields("SCost", "SAbilBuildInfo");

    AddRandomizedField("SAbilResearchInfo", type_int, ".Time");// we need the .Upgrade for the friendly name
    AddRandomizedField("SAbilResearchInfo", type_upgrade, ".Upgrade");
    CopyRandomizedFields("SCost", "SAbilResearchInfo");

    AddRandomizedField("SAbilTrainInfo", type_int, ".Time");// we need the .Unit[0] or .Effect for the friendly name
    AddRandomizedField("SAbilTrainInfo", type_effect, ".Effect");
    CopyRandomizedFields("SCost", "SAbilTrainInfo");// idk if this is needed

    AddRandomizedField("SUnitAbilData", type_ability, ".Link");
    AddRandomizedField("SUnitWeaponData", type_weapon, ".Link");

    AddRandomizedField("SAbilArmMagazineInfo", type_int, ".Time");// we need the .Unit for the friendly name
    CopyRandomizedFields("SCost", "SAbilArmMagazineInfo");

    AddRandomizedField("SAbilWarpTrainInfo", type_int, ".Time");// we need the .Unit for the friendly name
    CopyRandomizedFields("SCost", "SAbilWarpTrainInfo");

    AddRandomizedField("SEffectEnumArea", type_effect, ".Effect");
    AddRandomizedField("SEffectEnumArea", type_fixed, ".Radius");

    seed_was_locked = GameIsSeedLocked();
    //GameSetSeed(seed);

    //randomize_fields(c_gameCatalogAbil, "CAbilBuild", "ProtossBuild", "", protoss, 50);
    //randomize_fields(c_gameCatalogAbil, "CAbilBuild", "ZergBuild", "", zerg, 50);
    //randomize_fields(c_gameCatalogAbil, "CAbilResearch", "FactoryTechLabResearch", "", terran, 50);
    //randomize_fields(c_gameCatalogAbil, "CAbilResearch", "evolutionchamberresearch", "", zerg, 50);
    //randomize_fields(c_gameCatalogAbil, "CAbilEffectTarget", "PsiStorm", "", protoss, 50);

    randomize_economy();
    randomize_units(changes_per_race);

    race_changes[no_race].name = "General";
    race_changes[terran].name = "Terran";
    race_changes[protoss].name = "Protoss";
    race_changes[zerg].name = "Zerg";
    for(i=0; i<4 ; i+=1 ) {
        info(" ");
        log_changes(i);
    }
    info(" ");

    notes_log();
    GameSetSeedLocked(seed_was_locked);

    GameSetGlobalTimeScale(5);
}
