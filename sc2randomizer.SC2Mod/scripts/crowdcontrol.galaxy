
bank[16] cc_bank;
bank[16] cc_responses_bank;
string[16] cc_last_id;
trigger cc_ticker_trigger;
trigger cc_leave_game_trigger;

// TODO: proper handling of a bank per player

void cc_update_status(string status, int player) {
    string date;
    BankValueSetFromString(cc_responses_bank[player], "header", "status", status);
    date = libNtve_gf_FormatDateTimeasString(CurrentDateTimeGet());
    BankValueSetFromString(cc_responses_bank[player], "header", "date", date);
    BankSave(cc_responses_bank[player]);
    //BankWait(cc_responses_bank[player]);
    info("cc_update_status "+status+" "+IntToString(player));
}

void cc_set_last_id(string id, string status, int player) {
    string date;
    cc_last_id[player] = id;
    BankSectionRemove(cc_responses_bank[player], "responses");
    BankSectionCreate(cc_responses_bank[player], "responses");
    BankValueSetFromString(cc_responses_bank[player], "responses", id, status);
    date = libNtve_gf_FormatDateTimeasString(CurrentDateTimeGet());
    BankValueSetFromString(cc_responses_bank[player], "header", "date", date);
    BankSave(cc_responses_bank[player]);
}

bool cc_nukes() {
    unitgroup townhalls;
    // c_playerAny or just the current player?
    townhalls = GetUnitsOfTypes("Nexus CommandCenter CommandCenterFlying OrbitalCommand OrbitalCommandFlying PlanetaryFortress Hatchery Lair Hive", c_playerAny);
    return false;
}

bool cc_proc_request(int player, string code, string viewer, string params) {
    int iparam;
    if(bdebug) {
        notice(viewer + " used " + code + " " + params+" from player "+IntToString(player));
    }
    iparam = StringToInt(params);
    if( code == "nukes" ) {
        return cc_nukes();
    } else if( code == "giveminerals" ) {
        notice(viewer+" gave everyone "+IntToString(iparam)+" minerals");
        for(player=1; player<16; player+=1) {
            PlayerModifyPropertyInt(player, c_playerPropMinerals, c_playerPropOperAdd, iparam);
        }
    } else if( code == "givegas") {
        notice(viewer+" gave everyone "+IntToString(iparam)+" gas");
        for(player=1; player<16; player+=1) {
            PlayerModifyPropertyInt(player, c_playerPropVespene, c_playerPropOperAdd, iparam);
        }
    } else if( code == "takeminerals") {
        // TODO: check minerals/gas first, return failure when not enough
        notice(viewer+" took away "+IntToString(iparam)+" minerals from everyone");
        for(player=1; player<16; player+=1) {
            PlayerModifyPropertyInt(player, c_playerPropMinerals, c_playerPropOperSubtract, iparam);
        }
    } else if( code == "takegas") {
        notice(viewer+" took away "+IntToString(iparam)+" gas from everyone");
        for(player=1; player<16; player+=1) {
            PlayerModifyPropertyInt(player, c_playerPropVespene, c_playerPropOperSubtract, iparam);
        }
    } else {
        err("unknown crowd control effect");
        return false;
    }
    return true;
}

void cc_read_request(int player) {
    string code;
    string viewer;
    string id;
    string params;

    BankReload(cc_bank[player]);
    BankWait(cc_bank[player]);

    if( BankKeyExists(cc_bank[player], "request", "code") == false ) {
        debug("code doesn't exist");
        return;
    }

    code = BankValueGetAsString(cc_bank[player], "request", "code");
    viewer = BankValueGetAsString(cc_bank[player], "request", "DisplayViewer");
    id = BankValueGetAsString(cc_bank[player], "request", "id");
    params = BankValueGetAsString(cc_bank[player], "request", "params");

    if(id == cc_last_id[player]) {
        return;
    }

    if( cc_proc_request(player, code, viewer, params) ) {
        cc_set_last_id(id, "success", player);
    } else {
        cc_set_last_id(id, "fail", player);
    }
}

bool cc_ticker(bool testConds, bool runActions) {
    int player;

    for(player=1; player<16; player+=1) {
        if( PlayerIsActive(player) ) {
            cc_read_request(player);
        }
    }
    return true;
}

void StartCrowdControl() {
    int player;

    for(player=1; player<16; player+=1) {
        if( ! PlayerIsActive(player) ) {
            continue;
        }

        BankReload(cc_bank[player]);
        BankWait(cc_bank[player]);

        if( BankKeyExists(cc_bank[player], "request", "id") ) {
            cc_last_id[player] = BankValueGetAsString(cc_bank[player], "request", "id");
            cc_set_last_id(cc_last_id[player], "fail", player);
        }

        cc_update_status("playing", player);

        BankReload(cc_bank[player]);
        BankWait(cc_bank[player]);
    }
    debug("StartCrowdControl after waits");

    cc_ticker_trigger = TriggerCreate("cc_ticker");
    TriggerAddEventTimePeriodic(cc_ticker_trigger, 0.5, c_timeReal);
}

bool cc_leave_game(bool testConds, bool runActions) {
    int player;
    player = EventPlayer();
    if(PlayerIsActive(player)) {
        return true;
    }
    cc_update_status("exited", player);
    return true;
}

void init_crowd_control() {
    string date;
    int player;

    for(player=1; player<16; player+=1) {
        if( ! PlayerIsActive(player) ) {
            continue;
        }

        cc_bank[player] = BankLoad("CrowdControl", player);
        cc_responses_bank[player] = BankLoad("CrowdControlResponses", player);
        // loop through and clear all the response sections? or use keys instead of sections?
        BankSectionRemove(cc_responses_bank[player], "header");
        BankSectionCreate(cc_responses_bank[player], "header");
        BankValueSetFromString(cc_responses_bank[player], "header", "version", "0.23");
        cc_set_last_id("", "success", player);
        cc_update_status("starting", player);
    }

    cc_leave_game_trigger = TriggerCreate("cc_leave_game");
    TriggerAddEventPlayerLeft(cc_leave_game_trigger, c_playerAny, c_gameResultUndecided);
}
